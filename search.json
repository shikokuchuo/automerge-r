[{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":null,"dir":"","previous_headings":"","what":"CLAUDE.md","title":"CLAUDE.md","text":"file provides guidance Claude Code (claude.ai/code) working code repository.","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"project-overview","dir":"","previous_headings":"","what":"Project Overview","title":"CLAUDE.md","text":"R package (automerge) provides bindings Automerge Conflict-free Replicated Data Type (CRDT) library via C FFI (Foreign Function Interface). package early development phase minimal functionality implemented. Key Architecture: - R package structure C bindings Rust-based automerge-c library - package wraps automerge-c C API expose CRDT functionality R - Currently package registration constants defined - core functionality yet","code":""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"build-configuration","dir":"","previous_headings":"Build System","what":"Build Configuration","title":"CLAUDE.md","text":"package uses two-phase build approach controlled configure scripts: Searches standard prefixes: /usr/local, /usr, /opt/local, /opt/homebrew Falls back pkg-config available UTF-32 Verification: Compiles test program verify system library uses UTF-32 character indexing system library uses UTF-8 byte indexing, falls back bundled build Set AUTOMERGE_LIBS=1 environment variable force bundled build Located src/automerge/rust/automerge-c/ Uses CMake -DUTF32_INDEXING=flag Requires Rust toolchain >= 1.89.0 CMake >= 3.25","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"platform-specific-configuration","dir":"","previous_headings":"Build System","what":"Platform-Specific Configuration","title":"CLAUDE.md","text":"Links: -framework Security -framework Foundation (macOS), -pthread -ldl -lm -lrt (Linux) Uses MinGW Makefiles Links: -lws2_32 -luserenv -lbcrypt -lntdll CMake included Rtools43+","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"build-commands","dir":"","previous_headings":"Build System","what":"Build Commands","title":"CLAUDE.md","text":"","code":"# Install package (triggers configure + build) R CMD INSTALL .  # Build package tarball R CMD build .  # Check package (runs R CMD check) R CMD check automerge_*.tar.gz  # Clean build artifacts ./cleanup # Or manually: rm -f src/Makevars src/Makevars.win src/*.o src/*.so rm -rf src/automerge/rust/automerge-c/{build,install}"},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"development-workflow","dir":"","previous_headings":"Build System","what":"Development Workflow","title":"CLAUDE.md","text":"","code":"# Load package for development devtools::load_all()  # Run tests devtools::test() # Or: testthat::test_local()  # Build documentation devtools::document()  # Install locally devtools::install()"},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"r-layer-r","dir":"","previous_headings":"Code Structure","what":"R Layer (R/)","title":"CLAUDE.md","text":"Object types: AM_ROOT, AM_OBJ_TYPE_LIST, AM_OBJ_TYPE_MAP, AM_OBJ_TYPE_TEXT Mark expansion modes: AM_MARK_EXPAND_NONE///Internal maps (.am_obj_type_map, .am_mark_expand_map) convert strings C enum integers","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"c-layer-src","dir":"","previous_headings":"Code Structure","what":"C Layer (src/)","title":"CLAUDE.md","text":"Memory-safe wrappers: am_doc, am_syncstate (track ownership) Finalizers external pointers Safety limits: MAX_ERROR_MSG_SIZE=8192 Includes <automerge-c/automerge.h> system bundled build Currently empty CallEntries array (C functions registered yet) Disables dynamic symbol lookup security","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"build-templates","dir":"","previous_headings":"Code Structure","what":"Build Templates","title":"CLAUDE.md","text":"@PKG_CFLAGS@ @PKG_LIBS@ placeholders Currently compiles init.o Comments indicate future object files: document.o, objects.o, sync.o, conversions.o, errors.o, memory.o","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"development-status","dir":"","previous_headings":"","what":"Development Status","title":"CLAUDE.md","text":"Phase 1 (Current): Package infrastructure - Basic R package structure - Build system bundled automerge-c - Constants exported R - C function implementations yet Planned Implementation (based Makevars comments README): - Document operations: create, commit, access - Object operations: maps, lists, text - Synchronization: bidirectional sync protocols - Type conversions: R â†”ï¸Ž C â†”ï¸Ž Automerge types - Error handling memory management","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"testing","dir":"","previous_headings":"","what":"Testing","title":"CLAUDE.md","text":"","code":"# Run all tests Rscript -e 'devtools::test()'  # Or using R CMD check R CMD check automerge_*.tar.gz  # Current tests (tests/testthat/test-package.R): # - Package loads successfully # - Constants are correctly exported"},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"code-style","dir":"","previous_headings":"","what":"Code style","title":"CLAUDE.md","text":"Code comments made sparingly needed clarity Comments always address , rather ","code":""},{"path":"http://shikokuchuo.net/automerge-r/CLAUDE.html","id":"important-notes","dir":"","previous_headings":"","what":"Important Notes","title":"CLAUDE.md","text":"Indexing Conventions: package uses different indexing conventions different operations: 1-based indexing (element indices): List operations: am_get(), am_put(), am_delete(), am_insert() List indices work like R vectors: first element index 1 Counter operations lists: am_counter_increment() list objects 0-based indexing (inter-character positions): Text operations: am_text_splice() Cursor operations: am_cursor(), am_cursor_position() Mark operations: am_mark_create(), am_marks() Positions specify locations characters, characters Position 0 = first character, position 1 = 1st 2nd character distinction necessary represent â€œfirst characterâ€ 1-based indexing Example text â€œHelloâ€: UTF-32 Character Indexing: CMake build uses UTF-32 code point indexing (matches Râ€™s character semantics) text positions character counts use Unicode code points, bytes Example: â€œHelloðŸ˜€â€, emoji counts 1 character position 5 matches Râ€™s nchar() behavior: nchar(\"ðŸ˜€\") returns 1 JavaScript Note: JS uses UTF-16, positions may differ emoji Unicode characters Security Considerations: Input validation limits defined automerge.h Ownership tracking prevents double-free vulnerabilities Dynamic symbols disabled registration Dependencies: Zero R package dependencies (base R) System requirements: Rust >= 1.89.0, CMake >= 3.25 (building source) Licensing: MIT license bundled automerge-c (also MIT) - see LICENSE.note","code":"H e l l o  0 1 2 3 4 5  <- positions (0-based, between characters)"},{"path":"http://shikokuchuo.net/automerge-r/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 automerge R package authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (â€œSoftwareâ€), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED â€œâ€, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"what-is-automerge","dir":"Articles","previous_headings":"","what":"What is Automerge?","title":"Getting Started with automerge","text":"Automerge library enables automatic merging concurrent changes without conflicts. â€™s built concept Conflict-free Replicated Data Types (CRDTs), data structures designed safely replicated across multiple devices automatically merged.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"key-benefits","dir":"Articles","previous_headings":"What is Automerge?","what":"Key Benefits","title":"Getting Started with automerge","text":"Automatic conflict resolution: Multiple users can edit document simultaneously without manual conflict resolution Offline-first: Changes can made offline synchronized later Cross-platform: Documents created R can synced JavaScript, Python, implementations Version history: Complete change history preserved auditing debugging Collaborative: Perfect building collaborative applications like shared notebooks data pipelines","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Getting Started with automerge","text":"","code":"# From R-universe install.packages(\"automerge\", repos = \"https://shikokuchuo.r-universe.dev\")  # From GitHub pak::pak(\"shikokuchuo/automerge-r\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Getting Started with automerge","text":"Letâ€™s start fundamental operations:","code":"library(automerge)"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"creating-a-document","dir":"Articles","previous_headings":"Basic Usage","what":"Creating a Document","title":"Getting Started with automerge","text":"","code":"doc <- am_create() print(doc) #> <Automerge Document> #> Actor: bdcd346134f0d0c447095fadc6548a98  #> Root keys: 0"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"adding-data---three-approaches","dir":"Articles","previous_headings":"Basic Usage","what":"Adding Data - Three Approaches","title":"Getting Started with automerge","text":"Automerge provides multiple ways add data, functional R-idiomatic:","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"functional-api","dir":"Articles","previous_headings":"Basic Usage > Adding Data - Three Approaches","what":"1. Functional API","title":"Getting Started with automerge","text":"","code":"am_put(doc, AM_ROOT, \"name\", \"Alice\") am_put(doc, AM_ROOT, \"age\", 30L) am_put(doc, AM_ROOT, \"active\", TRUE) am_commit(doc, \"Initial data\")  am_get(doc, AM_ROOT, \"name\") #> [1] \"Alice\" am_get(doc, AM_ROOT, \"age\") #> [1] 30"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"s3-operators-r-idiomatic","dir":"Articles","previous_headings":"Basic Usage > Adding Data - Three Approaches","what":"2. S3 Operators (R-idiomatic)","title":"Getting Started with automerge","text":"","code":"doc[[\"email\"]] <- \"alice@example.com\" doc[[\"score\"]] <- 95.5  doc[[\"name\"]] #> [1] \"Alice\" doc[[\"age\"]] #> [1] 30  # List all keys names(doc) #> [1] \"active\" \"age\"    \"email\"  \"name\"   \"score\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"pipe-friendly-style","dir":"Articles","previous_headings":"Basic Usage > Adding Data - Three Approaches","what":"3. Pipe-Friendly Style","title":"Getting Started with automerge","text":"","code":"doc2 <- am_create() |>   am_put(AM_ROOT, \"name\", \"Bob\") |>   am_put(AM_ROOT, \"age\", 25L) |>   am_put(AM_ROOT, \"active\", TRUE) |>   am_commit(\"Initial setup\")  doc2 |> am_get(AM_ROOT, \"name\") #> [1] \"Bob\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"working-with-nested-structures","dir":"Articles","previous_headings":"","what":"Working with Nested Structures","title":"Getting Started with automerge","text":"Automerge supports nested data structures (maps within maps, lists within maps, etc.).","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"recursive-conversion","dir":"Articles","previous_headings":"Working with Nested Structures","what":"Recursive Conversion","title":"Getting Started with automerge","text":"simplest approach use Râ€™s native list structures, automatically converted:","code":"# Create document with nested structure in one call doc3 <- am_create() |>   am_put(     AM_ROOT,     \"company\",     list(       name = \"Acme Corp\",       founded = 2020L,       employees = list(         list(name = \"Alice\", role = \"Engineer\"),         list(name = \"Bob\", role = \"Designer\")       ),       office = list(         address = list(           street = \"123 Main St\",           city = \"Boston\",           zip = 02101L         ),         size = 5000.5       )     )   ) |>   am_commit(\"Add company data\")  # Access nested data (verbose way) company <- doc3[[\"company\"]] office <- am_get(doc3, company, \"office\") address <- am_get(doc3, office, \"address\") am_get(doc3, address, \"city\") #> [1] \"Boston\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"path-based-access","dir":"Articles","previous_headings":"Working with Nested Structures","what":"Path-Based Access","title":"Getting Started with automerge","text":"deep structures, path-based helpers make navigation much easier:","code":"# Much simpler - use path-based access am_get_path(doc3, c(\"company\", \"office\", \"address\", \"city\")) #> [1] \"Boston\"  # Create deep structure using paths doc4 <- am_create()  am_put_path(doc4, c(\"config\", \"database\", \"host\"), \"localhost\") am_put_path(doc4, c(\"config\", \"database\", \"port\"), 5432L) am_put_path(doc4, c(\"config\", \"cache\", \"enabled\"), TRUE) am_put_path(doc4, c(\"config\", \"cache\", \"ttl\"), 3600L)  # Retrieve values with paths am_get_path(doc4, c(\"config\", \"database\", \"host\")) #> [1] \"localhost\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"converting-r-data-structures","dir":"Articles","previous_headings":"Working with Nested Structures","what":"Converting R Data Structures","title":"Getting Started with automerge","text":"Use as_automerge() convert entire R structures :","code":"# Your existing R data config_data <- list(   app_name = \"MyApp\",   version = \"1.0.0\",   database = list(     host = \"localhost\",     port = 5432L,     credentials = list(       user = \"admin\",       password_hash = \"...\"     )   ),   features = list(\"auth\", \"api\", \"websocket\") )  # Convert to Automerge document doc5 <- as_automerge(config_data) am_commit(doc5, \"Initial configuration\")  # Easy access with paths am_get_path(doc5, c(\"database\", \"port\")) #> [1] 5432"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"working-with-lists","dir":"Articles","previous_headings":"","what":"Working with Lists","title":"Getting Started with automerge","text":"Lists R use 1-based indexing (standard R convention):","code":"# Create a document with a list doc6 <- am_create() am_put(doc6, AM_ROOT, \"items\", AM_OBJ_TYPE_LIST) items <- am_get(doc6, AM_ROOT, \"items\")  # Insert items am_insert(doc6, items, 1, \"first\") # Insert at index 1 am_insert(doc6, items, 2, \"second\") # Insert at index 2 am_insert(doc6, items, 3, \"third\") # Insert at index 3  # Or use the \"end\" marker to append am_insert(doc6, items, \"end\", \"fourth\") am_put(doc6, items, \"end\", \"fifth\")  # Get list length am_length(doc6, items) #> [1] 5  # Access by index am_get(doc6, items, 1) #> [1] \"first\" am_get(doc6, items, 2) #> [1] \"second\""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"text-objects-for-collaborative-editing","dir":"Articles","previous_headings":"Special Automerge Types","what":"Text Objects (for Collaborative Editing)","title":"Getting Started with automerge","text":"Regular strings use deterministic conflict resolution (one value wins). collaborative text editing, use text objects:","code":"doc7 <- am_create()  # Regular string (last-write-wins) am_put(doc7, AM_ROOT, \"title\", \"My Document\")  # Text object (CRDT - supports collaborative editing) am_put(doc7, AM_ROOT, \"content\", am_text(\"Initial content\")) text_obj <- am_get(doc7, AM_ROOT, \"content\")  # Text supports character-level operations # For the text \"Hello\": #  H e l l o # 0 1 2 3 4 5  <- positions (0-based, between characters)  am_text_splice(text_obj, 8, 0, \"amazing \") # Insert at position 8 am_text_get(text_obj) #> [1] \"Initial amazing content\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"counters-for-crdt-counting","dir":"Articles","previous_headings":"Special Automerge Types","what":"Counters (for CRDT Counting)","title":"Getting Started with automerge","text":"Counters special values can incremented/decremented without conflicts:","code":"doc8 <- am_create()  # Create a counter am_put(doc8, AM_ROOT, \"score\", am_counter(0))  am_counter_increment(doc8, AM_ROOT, \"score\", 10) am_counter_increment(doc8, AM_ROOT, \"score\", 5) am_counter_increment(doc8, AM_ROOT, \"score\", -3)  doc8[[\"score\"]] #> <Automerge Counter: 12 >"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"timestamps","dir":"Articles","previous_headings":"Special Automerge Types","what":"Timestamps","title":"Getting Started with automerge","text":"POSIXct timestamps natively supported:","code":"doc9 <- am_create()  am_put(doc9, AM_ROOT, \"created_at\", Sys.time()) am_put(doc9, AM_ROOT, \"updated_at\", Sys.time())  doc9[[\"created_at\"]] #> [1] \"2025-11-26 15:19:27 UTC\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"saving-and-loading-documents","dir":"Articles","previous_headings":"","what":"Saving and Loading Documents","title":"Getting Started with automerge","text":"Documents can saved binary format loaded later:","code":"# Save to binary format bytes <- am_save(doc)  # Save to file temp_file <- tempfile(fileext = \".automerge\") writeBin(bytes, temp_file)  # Load from binary doc_loaded <- am_load(bytes)  # Or load from file doc_from_file <- am_load(readBin(temp_file, \"raw\", 1e6))  # Verify data persisted doc_from_file[[\"name\"]] #> [1] \"Alice\""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"committing-changes","dir":"Articles","previous_headings":"Document Lifecycle","what":"Committing Changes","title":"Getting Started with automerge","text":"","code":"doc10 <- am_create()  # Make changes doc10[[\"x\"]] <- 1 doc10[[\"y\"]] <- 2  # Commit with message am_commit(doc10, \"Add x and y coordinates\")  # Make more changes doc10[[\"z\"]] <- 3 am_commit(doc10, \"Add z coordinate\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"forking-documents","dir":"Articles","previous_headings":"Document Lifecycle","what":"Forking Documents","title":"Getting Started with automerge","text":"Create independent copies:","code":"doc11 <- am_fork(doc10)  # Changes to fork don't affect original doc11[[\"w\"]] <- 4 doc10[[\"w\"]] # NULL - not in original #> NULL"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"merging-documents","dir":"Articles","previous_headings":"Document Lifecycle","what":"Merging Documents","title":"Getting Started with automerge","text":"Merge changes one document another:","code":"# Create two documents doc12 <- am_create() doc12[[\"source\"]] <- \"doc12\" doc12[[\"value1\"]] <- 100  doc13 <- am_create() doc13[[\"source\"]] <- \"doc13\" doc13[[\"value2\"]] <- 200  # Merge doc13 into doc12 am_merge(doc12, doc13)  # doc12 now has both values doc12[[\"value1\"]] #> [1] 100 doc12[[\"value2\"]] #> [1] 200 doc12[[\"source\"]] # One value wins deterministically for conflicting keys #> [1] \"doc12\""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"basic-synchronization","dir":"Articles","previous_headings":"","what":"Basic Synchronization","title":"Getting Started with automerge","text":"Automergeâ€™s key feature automatic synchronization documents:","code":"# Create two peers peer1 <- am_create() peer1[[\"edited_by\"]] <- \"peer1\" peer1[[\"data1\"]] <- 100 am_commit(peer1)  peer2 <- am_create() peer2[[\"edited_by\"]] <- \"peer2\" peer2[[\"data2\"]] <- 200 am_commit(peer2)  # Bidirectional sync (documents modified in place) rounds <- am_sync(peer1, peer2) rounds #> [1] 4  # Both documents now have all data peer1[[\"data1\"]] #> [1] 100 peer1[[\"data2\"]] #> [1] 200 peer2[[\"data1\"]] #> [1] 100 peer2[[\"data2\"]] #> [1] 200"},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with automerge","text":"Learn CRDT Concepts understand theory behind Automerge Explore Synchronization Patterns collaborative workflows Check Quick Reference one-page guide functions","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/automerge.html","id":"getting-help","dir":"Articles","previous_headings":"","what":"Getting Help","title":"Getting Started with automerge","text":"","code":"# Function help ?am_create ?am_put ?am_sync  # Package help ?automerge help(package = \"automerge\")  # All vignettes vignette(package = \"automerge\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"what-are-crdts","dir":"Articles","previous_headings":"","what":"What are CRDTs?","title":"Understanding CRDTs in Automerge","text":"Conflict-free Replicated Data Types (CRDTs) data structures can replicated across multiple computers modified independently without coordination. key property changes eventually synchronized, replicas converge state automatically - without manual conflict resolution.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"the-problem-crdts-solve","dir":"Articles","previous_headings":"What are CRDTs?","what":"The Problem CRDTs Solve","title":"Understanding CRDTs in Automerge","text":"Consider simple example without CRDTs: CRDT counter:","code":"Initial state: counter = 0  Alice's device (offline): counter = counter + 1  â†’ counter = 1 Bob's device (offline):   counter = counter + 2  â†’ counter = 2  When they sync: - If we use \"last write wins\": counter = 2 (Alice's change lost!) - If we use \"first write wins\": counter = 1 (Bob's change lost!) - Manual conflict resolution: Ask user to choose (annoying!) Initial state: counter = 0  Alice's device: increment(1) Bob's device:   increment(2)  When they sync: - CRDT automatically merges: counter = 3 (both changes preserved!)"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"crdt-properties","dir":"Articles","previous_headings":"What are CRDTs?","what":"CRDT Properties","title":"Understanding CRDTs in Automerge","text":"CRDTs properties: merge(merge(, B), C) = merge(, merge(B, C)) merge(, B) = merge(B, ) merge(, ) = properties ensure strong eventual consistency: devices see set changes converge state, regardless network delays, message reordering, duplicates.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"automerge-crdt-types","dir":"Articles","previous_headings":"","what":"Automerge CRDT Types","title":"Understanding CRDTs in Automerge","text":"Automerge implements several CRDT types, optimized different use cases.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"register-values-strings-numbers-booleans","dir":"Articles","previous_headings":"Automerge CRDT Types","what":"Register Values (Strings, Numbers, Booleans)","title":"Understanding CRDTs in Automerge","text":"simplest type: two replicas concurrently write different values key, one value wins. Automerge uses deterministic conflict resolution algorithm (based Lamport timestamps actor IDs) ensure replicas converge value. use: Simple values automatic conflict resolution acceptable (metadata, settings, labels). Trade-: One concurrent change lost, resolution deterministic replicas converge state.","code":"doc1 <- am_create() doc1[[\"name\"]] <- \"Alice\" doc1[[\"score\"]] <- 100 am_commit(doc1)  doc2 <- am_fork(doc1)  # Concurrent edits doc1[[\"name\"]] <- \"Alice Smith\" doc2[[\"name\"]] <- \"Alice Johnson\"  # Merge am_merge(doc1, doc2)  # One value wins (deterministic, all replicas agree) doc1[[\"name\"]] #> [1] \"Alice Johnson\""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"maps-nested-objects","dir":"Articles","previous_headings":"Automerge CRDT Types","what":"Maps (Nested Objects)","title":"Understanding CRDTs in Automerge","text":"Maps collections key-value pairs. key uses deterministic conflict resolution (one value wins), different keys can edited concurrently without conflict. use: Structured data multiple independent fields (user profiles, configuration objects). Merge behavior: Changes different keys merge cleanly. Changes key use deterministic conflict resolution.","code":"doc3 <- am_create() doc3[[\"user\"]] <- list(name = \"Alice\", age = 30L, city = \"Boston\") am_commit(doc3)  doc4 <- am_fork(doc3)  # Concurrent edits to different keys user3 <- am_get(doc3, AM_ROOT, \"user\") am_put(doc3, user3, \"age\", 31L)  user4 <- am_get(doc4, AM_ROOT, \"user\") am_put(doc4, user4, \"city\", \"New York\")  # Merge - both changes preserved am_merge(doc3, doc4)  # Both edits are present user_final <- am_get(doc3, AM_ROOT, \"user\") am_get(doc3, user_final, \"age\") #> [1] 31 am_get(doc3, user_final, \"city\") #> [1] \"New York\""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"lists-ordered-sequences","dir":"Articles","previous_headings":"Automerge CRDT Types","what":"Lists (Ordered Sequences)","title":"Understanding CRDTs in Automerge","text":"Lists use sophisticated CRDT algorithm preserves insertion order handles concurrent insertions elegantly. use: Ordered collections (task lists, sequences, timelines). Merge behavior: Concurrent insertions position preserved. algorithm ensures deterministic ordering based actor IDs. Limitation: cases insertion order perfectly preserved, primarily inserting elements reverse order. However, algorithm performs well common scenarios.","code":"doc5 <- am_create() am_put(doc5, AM_ROOT, \"items\", AM_OBJ_TYPE_LIST) items5 <- am_get(doc5, AM_ROOT, \"items\")  am_put(doc5, items5, \"end\", \"A\") am_put(doc5, items5, \"end\", \"C\") am_commit(doc5)  doc6 <- am_fork(doc5)  # Concurrent insertions at same position items6 <- am_get(doc6, AM_ROOT, \"items\") am_insert(doc5, items5, 2, \"B1\") # Insert between A and C am_insert(doc6, items6, 2, \"B2\") # Insert between A and C  # Merge am_merge(doc5, doc6)  # Both insertions preserved with deterministic ordering for (i in seq_len(am_length(doc5, items5))) {   print(am_get(doc5, items5, i)) } #> [1] \"A\" #> [1] \"B1\" #> [1] \"B2\" #> [1] \"C\""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"text-crdts-collaborative-text-editing","dir":"Articles","previous_headings":"Automerge CRDT Types","what":"Text CRDTs (Collaborative Text Editing)","title":"Understanding CRDTs in Automerge","text":"Text objects optimized character-level collaborative editing. handle concurrent insertions, deletions, edits gracefully. use: Collaborative documents, shared notes, code editors, chat messages. Merge behavior: Character-level operations merge intelligently. Positions tracked using stable identifiers, concurrent edits different positions donâ€™t interfere. Important: Regular strings (AM_VAL_TYPE_STR) use deterministic conflict resolution (one value wins). text objects (AM_OBJ_TYPE_TEXT) provide character-level CRDT merging.","code":"doc7 <- am_create() am_put(doc7, AM_ROOT, \"document\", am_text(\"The quick fox jumps\")) am_commit(doc7)  doc8 <- am_fork(doc7)  text7 <- am_get(doc7, AM_ROOT, \"document\") text8 <- am_get(doc8, AM_ROOT, \"document\")  # Concurrent edits (0-based inter-character positions) am_text_splice(text7, 10, 0, \"brown \") # Insert \"brown \" at position 10 am_text_splice(text8, 19, 0, \" high\") # Insert \" high\" at position 19 (end)  # Merge am_merge(doc7, doc8)  # Both edits preserved am_text_get(text7) #> [1] \"The quick brown fox jumps high\" # String (deterministic conflict resolution) doc9 <- am_create() doc9[[\"title\"]] <- \"Document\" doc10 <- am_fork(doc9)  doc9[[\"title\"]] <- \"My Document\" doc10[[\"title\"]] <- \"Our Document\" am_merge(doc9, doc10) doc9[[\"title\"]] # One value wins deterministically #> [1] \"Our Document\"  # Text object (CRDT) doc11 <- am_create() am_put(doc11, AM_ROOT, \"content\", am_text(\"Hello\")) doc12 <- am_fork(doc11)  text11 <- am_get(doc11, AM_ROOT, \"content\") text12 <- am_get(doc12, AM_ROOT, \"content\")  am_text_splice(text11, 5, 0, \" World\") am_text_splice(text12, 5, 0, \" Everyone\") am_merge(doc11, doc12)  am_text_get(text11) #> [1] \"Hello Everyone World\""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"counters","dir":"Articles","previous_headings":"Automerge CRDT Types","what":"Counters","title":"Understanding CRDTs in Automerge","text":"Counters classic CRDT adds increments replicas. use: Vote counts, like counts, inventory quantities, collaborative counters. Merge behavior: increments (positive negative) summed automatically.","code":"doc13 <- am_create() am_put(doc13, AM_ROOT, \"likes\", am_counter(0)) am_commit(doc13)  doc14 <- am_fork(doc13)  # Concurrent increments am_counter_increment(doc13, AM_ROOT, \"likes\", 3) am_counter_increment(doc14, AM_ROOT, \"likes\", 5) am_counter_increment(doc14, AM_ROOT, \"likes\", -1)  # Merge am_merge(doc13, doc14)  # Sum of all increments doc13[[\"likes\"]] #> <Automerge Counter: 7 >"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"timestamps","dir":"Articles","previous_headings":"Automerge CRDT Types","what":"Timestamps","title":"Understanding CRDTs in Automerge","text":"Timestamps record value set. use deterministic conflict resolution semantics (one value wins). use: Audit trails, modification times, temporal metadata.","code":"doc15 <- am_create() doc15[[\"created_at\"]] <- Sys.time() am_commit(doc15)  Sys.sleep(0.1)  doc16 <- am_fork(doc15)  doc15[[\"updated_at\"]] <- Sys.time() doc16[[\"updated_at\"]] <- Sys.time()  am_merge(doc15, doc16)  doc15[[\"created_at\"]] #> [1] \"2025-11-26 15:19:30 UTC\" doc15[[\"updated_at\"]] #> [1] \"2025-11-26 15:19:30 UTC\""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"cursors-stable-position-tracking","dir":"Articles","previous_headings":"Advanced Text Features","what":"Cursors (Stable Position Tracking)","title":"Understanding CRDTs in Automerge","text":"Cursors maintain stable positions text even document edited. use: Text editors (cursor tracking), collaborative commenting (position references).","code":"doc17 <- am_create() am_put(doc17, AM_ROOT, \"text\", am_text(\"Hello World\")) text17 <- am_get(doc17, AM_ROOT, \"text\")  # Create cursor at position 6 (0-based: after \"Hello \") cursor <- am_cursor(text17, 6)  # Insert text before cursor am_text_splice(text17, 0, 0, \"Hi \")  # Cursor automatically adjusts new_pos <- am_cursor_position(text17, cursor) new_pos # Cursor moved with text from original position 6 #> [1] 9"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"marks-text-formatting","dir":"Articles","previous_headings":"Advanced Text Features","what":"Marks (Text Formatting)","title":"Understanding CRDTs in Automerge","text":"Marks attach metadata text ranges, useful formatting annotations. use: Rich text editors, collaborative annotations, syntax highlighting. Mark expansion: Controls marks behave text inserted boundaries: - \"none\": Mark doesnâ€™t expand - \"\": Expands include text inserted start - \"\": Expands include text inserted end - \"\": Expands boundaries","code":"doc18 <- am_create() am_put(doc18, AM_ROOT, \"text\", am_text(\"Hello World\")) text18 <- am_get(doc18, AM_ROOT, \"text\")  # Mark \"Hello\" as bold (positions 0-4, 0-based) am_mark_create(text18, 0, 5, \"bold\", TRUE, expand = \"none\")  # Mark \"World\" as italic (positions 6-10) am_mark_create(text18, 6, 11, \"italic\", TRUE, expand = \"none\")  # Query marks marks <- am_marks(text18) str(marks) #> List of 2 #>  $ :List of 4 #>   ..$ name : chr \"bold\" #>   ..$ value: logi TRUE #>   ..$ start: int 0 #>   ..$ end  : int 5 #>  $ :List of 4 #>   ..$ name : chr \"italic\" #>   ..$ value: logi TRUE #>   ..$ start: int 6 #>   ..$ end  : int 11  # Marks at specific position marks_at_pos <- am_marks_at(text18, 2) # Position 2 (in \"Hello\") str(marks_at_pos) #> List of 1 #>  $ :List of 4 #>   ..$ name : chr \"bold\" #>   ..$ value: logi TRUE #>   ..$ start: int 0 #>   ..$ end  : int 5 doc19 <- am_create() am_put(doc19, AM_ROOT, \"text\", am_text(\"Hello\")) text19 <- am_get(doc19, AM_ROOT, \"text\")  # Mark with expansion am_mark_create(text19, 0, 5, \"bold\", TRUE, expand = \"after\")  # Insert at end of mark am_text_splice(text19, 5, 0, \" World\")  # Mark expands to include \"World\" marks <- am_marks(text19) str(marks) #> List of 1 #>  $ :List of 4 #>   ..$ name : chr \"bold\" #>   ..$ value: logi TRUE #>   ..$ start: int 0 #>   ..$ end  : int 11"},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"storage-growth","dir":"Articles","previous_headings":"CRDT Design Trade-offs","what":"Storage Growth","title":"Understanding CRDTs in Automerge","text":"CRDTs preserve operation history enable merging. means document size grows number operations, just current content size. Mitigation strategies: Commit less frequently bulk changes Compact history periodically (future feature) Use appropriate granularity (donâ€™t make objects fine-grained)","code":"doc20 <- am_create()  # Make many edits for (i in 1:100) {   doc20[[paste0(\"key\", i)]] <- i } am_commit(doc20)  # Size includes all history length(am_save(doc20)) #> [1] 508"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"deletions-and-concurrent-operations","dir":"Articles","previous_headings":"CRDT Design Trade-offs","what":"Deletions and Concurrent Operations","title":"Understanding CRDTs in Automerge","text":"Deleted items leave tombstones ensure consistent deletion across replicas. delete operation conflicts update operation, Automerge specific resolution rules: Maps Lists: one replica deletes key/element another updates concurrently, update takes precedence. updated value retained merged document. Double deletion: replicas delete key/element, key/element removed merged document.","code":"# Map: Deletion vs concurrent update - update wins doc21 <- am_create() doc21[[\"temp\"]] <- \"value\" am_commit(doc21)  doc22 <- am_fork(doc21)  am_delete(doc21, AM_ROOT, \"temp\") am_commit(doc21)  doc22[[\"temp\"]] <- \"updated\" am_commit(doc22)  am_merge(doc21, doc22) doc21[[\"temp\"]] # Update takes precedence over delete #> [1] \"updated\" # List: Delete and insert at same position - both operations apply doc23 <- am_create() am_put(doc23, AM_ROOT, \"items\", AM_OBJ_TYPE_LIST) items23 <- am_get(doc23, AM_ROOT, \"items\") am_put(doc23, items23, \"end\", \"A\") am_put(doc23, items23, \"end\", \"B\") am_put(doc23, items23, \"end\", \"C\") am_commit(doc23)  doc24 <- am_fork(doc23) items24 <- am_get(doc24, AM_ROOT, \"items\")  am_delete(doc23, items23, 2) am_insert(doc24, items24, 2, \"X\")  am_merge(doc23, doc24)  for (i in seq_len(am_length(doc23, items23))) {   print(am_get(doc23, items23, i)) } #> [1] \"A\" #> [1] \"X\" #> [1] \"C\""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"choose-the-right-crdt-type","dir":"Articles","previous_headings":"Best Practices","what":"1. Choose the Right CRDT Type","title":"Understanding CRDTs in Automerge","text":"Simple values: Use regular types (strings, numbers, booleans) Structured data: Use maps objects independent fields Ordered collections: Use lists sequences Collaborative text: Use text objects, strings Counters: Use counter CRDT, integers","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"design-for-commutativity","dir":"Articles","previous_headings":"Best Practices","what":"2. Design for Commutativity","title":"Understanding CRDTs in Automerge","text":"Structure data concurrent operations naturally merge well:","code":"# Good: Independent counters per user doc_good <- am_create() doc_good[[\"votes\"]] <- list(   alice = am_counter(0),   bob = am_counter(0) )  # Better than: Single counter for all votes doc_bad <- am_create() doc_bad[[\"total_votes\"]] <- am_counter(0) # Loses attribution"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"commit-at-logical-boundaries","dir":"Articles","previous_headings":"Best Practices","what":"3. Commit at Logical Boundaries","title":"Understanding CRDTs in Automerge","text":"Group related changes commits:","code":"doc25 <- am_create()  # Good: Atomic transaction doc25[[\"user\"]] <- list(name = \"Alice\", age = 30L, city = \"Boston\") am_commit(doc25, \"Add user Alice\")  # Bad: Many micro-commits (increases storage) doc25[[\"status\"]] <- \"active\" am_commit(doc25, \"Set status\") doc25[[\"role\"]] <- \"admin\" am_commit(doc25, \"Set role\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"handle-concurrent-conflicts-gracefully","dir":"Articles","previous_headings":"Best Practices","what":"4. Handle Concurrent Conflicts Gracefully","title":"Understanding CRDTs in Automerge","text":"Understand conflicts inevitable:","code":"doc26 <- am_create() doc26[[\"status\"]] <- \"draft\" am_commit(doc26)  doc27 <- am_fork(doc26)  doc26[[\"status\"]] <- \"published\" doc27[[\"status\"]] <- \"archived\"  am_merge(doc26, doc27)  # One will win - application should handle both states sensibly doc26[[\"status\"]] # Should be prepared for either 'published' or 'archived' #> [1] \"published\""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Understanding CRDTs in Automerge","text":"Automerge Documentation CRDT Research Papers Conflict-Free Replicated Data Types (Paper)","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/crdt-concepts.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Understanding CRDTs in Automerge","text":"Learn Synchronization Patterns use CRDTs practice Check Quick Reference available functions","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Synchronization Protocol","text":"Automergeâ€™s synchronization protocol enables multiple peers exchange changes converge document state. protocol efficient, handling missing changes peers, works transport (files, HTTP, WebSockets, etc.).","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"high-level-sync-recommended","dir":"Articles","previous_headings":"","what":"High-Level Sync (Recommended)","title":"Synchronization Protocol","text":"use cases, use high-level sync helpers handle protocol automatically.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"bidirectional-sync","dir":"Articles","previous_headings":"High-Level Sync (Recommended)","what":"Bidirectional Sync","title":"Synchronization Protocol","text":"simplest way synchronize two documents: use: Simple peer--peer synchronization sides need changes.","code":"# Create two peers with different data peer1 <- am_create() peer1[[\"edited_by\"]] <- \"peer1\" peer1[[\"data1\"]] <- 100 am_commit(peer1, \"Peer1 changes\")  peer2 <- am_create() peer2[[\"edited_by\"]] <- \"peer2\" peer2[[\"data2\"]] <- 200 am_commit(peer2, \"Peer2 changes\")  # Automatic bidirectional sync (documents modified in place) rounds <- am_sync(peer1, peer2)  rounds #> [1] 4  # Both documents now have all data peer1[[\"data1\"]] #> [1] 100 peer1[[\"data2\"]] #> [1] 200 peer2[[\"data1\"]] #> [1] 100 peer2[[\"data2\"]] #> [1] 200"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"one-way-merge","dir":"Articles","previous_headings":"High-Level Sync (Recommended)","what":"One-Way Merge","title":"Synchronization Protocol","text":"pulling changes one document another without sending changes back: use: Client pulling updates server, importing changes another peer.","code":"# Create source document source <- am_create() source[[\"version\"]] <- \"2.0\" source[[\"features\"]] <- list(\"auth\", \"api\") am_commit(source)  # Create target document target <- am_create() target[[\"version\"]] <- \"1.0\" target[[\"development\"]] <- TRUE am_commit(target)  # Pull changes from source to target am_merge(target, source)  # Target now has source's changes target[[\"version\"]] #> [1] \"1.0\"  # Source is unchanged names(source) #> [1] \"features\" \"version\""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"low-level-sync-protocol","dir":"Articles","previous_headings":"","what":"Low-Level Sync Protocol","title":"Synchronization Protocol","text":"network protocols fine-grained control, use low-level API.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"basic-protocol-flow","dir":"Articles","previous_headings":"Low-Level Sync Protocol","what":"Basic Protocol Flow","title":"Synchronization Protocol","text":"","code":"# Create two peers peer3 <- am_create() peer3[[\"source\"]] <- \"peer3\" am_commit(peer3)  peer4 <- am_create() peer4[[\"source\"]] <- \"peer4\" am_commit(peer4)  # Each peer maintains its own sync state sync3 <- am_sync_state_new() sync4 <- am_sync_state_new()  # Exchange messages until converged round <- 0 repeat {   round <- round + 1    # Peer 3 generates message   msg3 <- am_sync_encode(peer3, sync3)   if (is.null(msg3)) {     break   } # No more messages    # Peer 4 receives and processes   am_sync_decode(peer4, sync4, msg3)    # Peer 4 generates response   msg4 <- am_sync_encode(peer4, sync4)   if (is.null(msg4)) {     break   } # No more messages    # Peer 3 receives and processes   am_sync_decode(peer3, sync3, msg4)    if (round > 100) {     warning(\"Sync did not converge in 100 rounds\")     break   } }  round #> [1] 3 peer3[[\"source\"]] #> [1] \"peer4\" peer4[[\"source\"]] #> [1] \"peer4\""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"protocol-components","dir":"Articles","previous_headings":"Low-Level Sync Protocol","what":"Protocol Components","title":"Synchronization Protocol","text":"Sync State (am_sync_state_new()): Tracks peer knows Document-independent (can reused) preserved across sessions efficiency Sync Encode (am_sync_encode(doc, sync_state)): Generates sync message send peer Returns NULL changes send Message binary (raw vector) Sync Decode (am_sync_decode(doc, sync_state, message)): Receives sync message peer Updates document sync state Returns document invisibly chaining","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"change-based-synchronization","dir":"Articles","previous_headings":"","what":"Change-Based Synchronization","title":"Synchronization Protocol","text":"scenarios want explicit control individual changes:","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"exporting-and-importing-changes","dir":"Articles","previous_headings":"Change-Based Synchronization","what":"Exporting and Importing Changes","title":"Synchronization Protocol","text":"","code":"# Create base document that will be shared base_doc <- am_create() base_doc[[\"v1\"]] <- \"first\" am_commit(base_doc, \"Version 1\")  # Fork to create two peers with shared history peer_a <- am_fork(base_doc) peer_b <- am_fork(base_doc)  # Remember the fork point fork_heads <- am_get_heads(peer_a)  # Peer A makes changes peer_a[[\"v2\"]] <- \"second\" am_commit(peer_a, \"Version 2\")  peer_a[[\"v3\"]] <- \"third\" am_commit(peer_a, \"Version 3\")  # Export changes since fork point changes <- am_get_changes(peer_a, fork_heads)  length(changes) #> [1] 2  # Peer B applies the changes am_apply_changes(peer_b, changes)  # Verify both peers are in sync peer_b[[\"v2\"]] #> [1] \"second\" peer_b[[\"v3\"]] #> [1] \"third\""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"saving-changes-to-files","dir":"Articles","previous_headings":"Change-Based Synchronization","what":"Saving Changes to Files","title":"Synchronization Protocol","text":"use: Git-like workflows, change logs, selective sync.","code":"# Save individual changes to files temp_dir <- tempdir() for (i in seq_along(changes)) {   change_file <- file.path(temp_dir, sprintf(\"change_%03d.bin\", i))   writeBin(changes[[i]], change_file) }  # Later: load and apply changes loaded_changes <- list() for (i in seq_along(changes)) {   change_file <- file.path(temp_dir, sprintf(\"change_%03d.bin\", i))   loaded_changes[[i]] <- readBin(change_file, \"raw\", file.size(change_file)) }  # Apply loaded changes to a peer peer_c <- am_fork(base_doc) am_apply_changes(peer_c, loaded_changes)  # Verify peer_c[[\"v3\"]] #> [1] \"third\""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"understanding-heads","dir":"Articles","previous_headings":"Document Heads and History","what":"Understanding Heads","title":"Synchronization Protocol","text":"Heads recent commits documentâ€™s history. represent current stateâ€™s frontier change graph. Heads useful : Tracking changes â€™ve already seen Computing incremental updates Detecting whether documents diverged","code":"# Create document and make changes doc_main <- am_create() doc_main[[\"version\"]] <- \"1.0\" am_commit(doc_main, \"Initial version\")  # Get heads (fingerprint of current state) heads_v1 <- am_get_heads(doc_main) length(heads_v1) #> [1] 1  # Make more changes doc_main[[\"version\"]] <- \"2.0\" doc_main[[\"feature\"]] <- \"new\" am_commit(doc_main, \"Version 2\")  heads_v2 <- am_get_heads(doc_main) identical(heads_v1, heads_v2) #> [1] FALSE"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"working-with-history","dir":"Articles","previous_headings":"Document Heads and History","what":"Working with History","title":"Synchronization Protocol","text":"","code":"# Get full change history history <- am_get_history(doc_main) length(history) #> [1] 2  # History includes all commits ever made # Each entry contains metadata about a commit  # Get changes between two points in history changes_since_v1 <- am_get_changes(doc_main, heads_v1) str(changes_since_v1) #> List of 1 #>  $ : raw [1:126] 85 6f 4a 83 ..."},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"incremental-sync-pattern","dir":"Articles","previous_headings":"Document Heads and History","what":"Incremental Sync Pattern","title":"Synchronization Protocol","text":"Common pattern: track last sync point send new changes","code":"# Server document that accumulates changes server <- am_create() server[[\"users\"]] <- 0L am_commit(server, \"Initialize\")  # Client syncs and remembers server state client <- am_fork(server) last_sync_heads <- am_get_heads(server)  # Client makes local changes client[[\"users\"]] <- 1L client[[\"local_cache\"]] <- TRUE am_commit(client, \"Client updates\")  # Server receives changes from other clients server[[\"users\"]] <- 5L server[[\"server_config\"]] <- \"production\" am_commit(server, \"Server updates\")  # Client pulls only new server changes since last sync new_changes <- am_get_changes(server, last_sync_heads) length(new_changes) #> [1] 1  am_apply_changes(client, new_changes)  # Update sync point last_sync_heads <- am_get_heads(server)  # Client now has server's changes client[[\"server_config\"]] #> [1] \"production\"  # Server can also pull client's changes client_changes <- am_get_changes(client, am_get_heads(server)) am_apply_changes(server, client_changes)  server[[\"local_cache\"]] #> [1] TRUE"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"detecting-divergence","dir":"Articles","previous_headings":"Document Heads and History","what":"Detecting Divergence","title":"Synchronization Protocol","text":"","code":"# Create two peers that will diverge peer_x <- am_create() peer_x[[\"id\"]] <- \"x\" am_commit(peer_x)  peer_y <- am_fork(peer_x)  # Remember common state common_heads <- am_get_heads(peer_x)  # Both make different changes peer_x[[\"data_x\"]] <- \"from X\" am_commit(peer_x, \"X's change\")  peer_y[[\"data_y\"]] <- \"from Y\" am_commit(peer_y, \"Y's change\")  # Check if they've diverged x_heads <- am_get_heads(peer_x) y_heads <- am_get_heads(peer_y)  identical(x_heads, y_heads) #> [1] FALSE  # Get each peer's changes since common state x_changes <- am_get_changes(peer_x, common_heads) y_changes <- am_get_changes(peer_y, common_heads)  str(x_changes) #> List of 1 #>  $ : raw [1:109] 85 6f 4a 83 ... str(y_changes) #> List of 1 #>  $ : raw [1:109] 85 6f 4a 83 ...  # Sync to merge divergent histories rounds <- am_sync(peer_x, peer_y) rounds #> [1] 4  # After sync, heads are identical again identical(am_get_heads(peer_x), am_get_heads(peer_y)) #> [1] TRUE"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"concurrent-edits","dir":"Articles","previous_headings":"","what":"Concurrent Edits","title":"Synchronization Protocol","text":"Understanding concurrent edits merge:","code":"# Create shared starting point base <- am_create() base[[\"counter\"]] <- am_counter(0) base[[\"status\"]] <- \"draft\" am_commit(base)  # Fork to two editors editor1 <- am_fork(base) editor2 <- am_fork(base)  # Concurrent edits # Editor 1: increment counter, change status am_counter_increment(editor1, AM_ROOT, \"counter\", 5) editor1[[\"status\"]] <- \"review\" am_commit(editor1, \"Editor 1 changes\")  # Editor 2: increment counter differently, change status differently am_counter_increment(editor2, AM_ROOT, \"counter\", 3) editor2[[\"status\"]] <- \"published\" am_commit(editor2, \"Editor 2 changes\")  # Sync editors rounds <- am_sync(editor1, editor2)  # Counter: Both increments sum (CRDT) editor1[[\"counter\"]] #> <Automerge Counter: 8 >  # Status: Deterministic conflict resolution (one value wins) editor1[[\"status\"]] #> [1] \"review\""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"the-sync-frequency-tradeoff","dir":"Articles","previous_headings":"Sync Performance","what":"The Sync Frequency Tradeoff","title":"Synchronization Protocol","text":"â€™s fundamental tradeoff collaboration latency efficiency: Batching creates smaller documents : Fewer commit metadata entries Better compression related changes Less overhead commit boundaries","code":"# Strategy A: Frequent sync (lower latency, more overhead) doc_frequent <- am_create() peer_frequent <- am_create()  sync_count_frequent <- 0 for (i in 1:10) {   doc_frequent[[paste0(\"k\", i)]] <- i   am_commit(doc_frequent, paste(\"Change\", i))    rounds <- am_sync(doc_frequent, peer_frequent)   sync_count_frequent <- sync_count_frequent + 1 }  # 10 separate commits, 10 sync operations sync_count_frequent #> [1] 10  # Strategy B: Batched commits (higher latency, less overhead) doc_batched <- am_create() peer_batched <- am_create()  # Batch all changes into one commit for (i in 1:10) {   doc_batched[[paste0(\"k\", i)]] <- i } am_commit(doc_batched, \"Batch of 10 changes\")  rounds <- am_sync(doc_batched, peer_batched)  # 1 commit, 1 sync operation rounds #> [1] 4  # Compare document sizes length(am_save(doc_frequent)) #> [1] 265 length(am_save(doc_batched)) #> [1] 186"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"choosing-a-strategy","dir":"Articles","previous_headings":"Sync Performance","what":"Choosing a Strategy","title":"Synchronization Protocol","text":"Use frequent syncs : Multiple users editing simultaneously Low-latency collaboration critical (real-time editing) Users need see â€™s changes quickly Working reliable, fast networks Use batched commits : Single user making many changes Optimizing storage/bandwidth Syncing slow metered connections Changes logically related (e.g., form submission) Hybrid approach (recommended cases):","code":"# Batch related changes, sync periodically doc_hybrid <- am_create()  # User fills out a form (batch these) doc_hybrid[[\"name\"]] <- \"Alice\" doc_hybrid[[\"email\"]] <- \"alice@example.com\" doc_hybrid[[\"preferences\"]] <- list(\"theme\" = \"dark\") am_commit(doc_hybrid, \"Update user profile\")  # Sync after logical unit of work # result <- sync_with_server(doc_hybrid)  # Later: another logical unit doc_hybrid[[\"last_login\"]] <- Sys.time() am_commit(doc_hybrid, \"Record login\")  # Sync again # result <- sync_with_server(doc_hybrid)"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"reusing-sync-state","dir":"Articles","previous_headings":"Sync Performance","what":"Reusing Sync State","title":"Synchronization Protocol","text":"Sync state tracks peer seen, enabling efficient incremental sync: persist sync state: Long-lived connections (WebSocket servers) Periodic sync jobs (cron, scheduled tasks) Client apps reconnect frequently Reduces redundant data transfer significantly","code":"# Without reusing sync state (inefficient) doc_no_reuse <- am_create() doc_no_reuse[[\"v1\"]] <- 1 am_commit(doc_no_reuse)  peer_no_reuse <- am_create()  # First sync rounds1 <- am_sync(doc_no_reuse, peer_no_reuse) rounds1 #> [1] 4  # Add more changes doc_no_reuse[[\"v2\"]] <- 2 am_commit(doc_no_reuse)  # Second sync (creates new sync state, may resend some data) rounds2 <- am_sync(doc_no_reuse, peer_no_reuse) rounds2 #> [1] 4  # With reusing sync state (efficient) doc_reuse <- am_create() doc_reuse[[\"v1\"]] <- 1 am_commit(doc_reuse)  peer_reuse <- am_create() sync_state_local <- am_sync_state_new() sync_state_peer <- am_sync_state_new()  # Manual sync with persistent state msg1 <- am_sync_encode(doc_reuse, sync_state_local) am_sync_decode(peer_reuse, sync_state_peer, msg1) msg2 <- am_sync_encode(peer_reuse, sync_state_peer)  if (!is.null(msg2)) {   am_sync_decode(doc_reuse, sync_state_local, msg2) }  # Add more changes doc_reuse[[\"v2\"]] <- 2 am_commit(doc_reuse)  # Second sync reuses state (only sends new changes) msg3 <- am_sync_encode(doc_reuse, sync_state_local) am_sync_decode(peer_reuse, sync_state_peer, msg3)  # Sync state remembers what was already exchanged"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"measuring-performance","dir":"Articles","previous_headings":"Sync Performance","what":"Measuring Performance","title":"Synchronization Protocol","text":"","code":"# Compare efficiency of different approaches measure_sync <- function(n_changes, batch_size) {   doc <- am_create()   peer <- am_create()    changes_made <- 0   syncs_performed <- 0    for (i in seq_len(n_changes)) {     doc[[paste0(\"k\", i)]] <- i     changes_made <- changes_made + 1      # Commit every batch_size changes     if (changes_made %% batch_size == 0) {       am_commit(doc, sprintf(\"Batch at %d\", changes_made))       rounds <- am_sync(doc, peer)       syncs_performed <- syncs_performed + 1     }   }    # Final commit if needed   if (changes_made %% batch_size != 0) {     am_commit(doc, \"Final batch\")     rounds <- am_sync(doc, peer)     syncs_performed <- syncs_performed + 1   }    list(     changes = changes_made,     syncs = syncs_performed,     size = length(am_save(doc))   ) }  # No batching: commit and sync after every change result_no_batch <- measure_sync(20, 1)  # Medium batching: commit every 5 changes result_medium <- measure_sync(20, 5)  # Full batching: single commit at end result_full <- measure_sync(20, 20)  # Compare results result_no_batch$syncs #> [1] 20 result_medium$syncs #> [1] 4 result_full$syncs #> [1] 1  # Document sizes result_no_batch$size #> [1] 461 result_medium$size #> [1] 276 result_full$size #> [1] 233"},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Synchronization Protocol","text":"Learn CRDT Concepts understand merge behavior Check Quick Reference sync functions","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/sync-protocol.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Synchronization Protocol","text":"Local-First Software","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"automerge-r-package-quick-reference","dir":"Articles","previous_headings":"","what":"Automerge R Package Quick Reference","title":"Quick Reference","text":"One-page reference automerge package. See full documentation ?function_name.","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"installation","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Installation","title":"Quick Reference","text":"","code":"# From R-universe install.packages(\"automerge\", repos = \"https://shikokuchuo.r-universe.dev\")  # From GitHub pak::pak(\"shikokuchuo/automerge-r\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"document-lifecycle","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Document Lifecycle","title":"Quick Reference","text":"","code":"library(automerge)  # Create doc <- am_create() # New document doc <- am_create(\"fd3ca50687f13477f1f9ea2b216b958a\") # With custom actor ID  # Load/Save bytes <- am_save(doc) # Save to bytes doc <- am_load(bytes) # Load from bytes  # Actor ID actor <- am_get_actor(doc) # Get actor ID (raw bytes) actor_hex <- am_get_actor_hex(doc) # Get actor ID as hex string am_set_actor(doc, actor_hex) # Set actor ID (raw, hex, or NULL)  # Fork/Merge doc2 <- am_fork(doc) # Create independent copy am_merge(doc, doc2) # Merge doc2 into doc1  # Transactions am_commit(doc, \"message\") # Commit changes am_rollback(doc) # Cancel pending changes"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"basic-access-maps","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Basic Access (Maps)","title":"Quick Reference","text":"","code":"# S3 operators doc[[\"key\"]] <- \"value\" # Set value value <- doc[[\"key\"]] # Get value doc$key <- value # Alternative syntax value <- doc$key # Alternative syntax  # Functional API am_delete(doc, AM_ROOT, \"key\") # Delete key am_put(doc, AM_ROOT, \"key\", value) # Set value value <- am_get(doc, AM_ROOT, \"key\") # Get value  # Introspection keys <- names(doc) # Get all keys keys <- am_keys(doc, AM_ROOT) # Functional version n <- length(doc) # Number of keys n <- am_length(doc, AM_ROOT) # Functional version"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"nested-objects","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Nested Objects","title":"Quick Reference","text":"","code":"# Automatic recursive conversion (recommended) am_put(   doc,   AM_ROOT,   \"user\",   list(     name = \"Alice\",     age = 30L,     address = list(city = \"NYC\", zip = 10001L)   ) )  # Path-based access (simple for deep structures) am_put_path(doc, c(\"user\", \"address\", \"city\"), \"Boston\") city <- am_get_path(doc, c(\"user\", \"address\", \"city\")) am_delete_path(doc, c(\"user\", \"address\"))  # Manual access user_obj <- am_get(doc, AM_ROOT, \"user\") am_put(doc, user_obj, \"name\", \"Bob\") name <- am_get(doc, user_obj, \"name\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"lists","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Lists","title":"Quick Reference","text":"","code":"# Create list am_put(doc, AM_ROOT, \"items\", AM_OBJ_TYPE_LIST) items <- am_get(doc, AM_ROOT, \"items\")  # Operations (1-based indexing) am_insert(doc, items, 1, \"first\") # Insert at index 1 am_put(doc, items, 1, \"FIRST\") # Replace at index 1 am_put(doc, items, \"end\", \"append\") # Append to end value <- am_get(doc, items, 1) # Get index 1 am_delete(doc, items, 1) # Delete index 1  # Introspection n <- am_length(doc, items) # List length"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"text-objects","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Text Objects","title":"Quick Reference","text":"","code":"# Text objects use 0-based inter-character positions # For the text \"Hello\": #  H e l l o # 0 1 2 3 4 5  <- positions (0-based, between characters)  # Create text object am_put(doc, AM_ROOT, \"content\", am_text(\"Hello\")) text_obj <- am_get(doc, AM_ROOT, \"content\")  # Operations am_text_splice(text_obj, 5, 0, \" World\") # Insert at position 5 content <- am_text_get(text_obj) # Get full text  # Cursors (stable positions) cursor <- am_cursor(text_obj, 5) # Create cursor at position 5 pos <- am_cursor_position(text_obj, cursor) # Get current position  # Marks (formatting) am_mark_create(text_obj, 0, 5, \"bold\", TRUE, expand = \"none\") marks <- am_marks(text_obj) # Get all marks marks_at <- am_marks_at(text_obj, 2) # Marks at position 2"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"value-types","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Value Types","title":"Quick Reference","text":"","code":"# NULL am_put(doc, AM_ROOT, \"null\", NULL)  # Boolean am_put(doc, AM_ROOT, \"bool\", TRUE)  # Integer am_put(doc, AM_ROOT, \"int\", 42L)  # Double am_put(doc, AM_ROOT, \"float\", 3.14)  # String am_put(doc, AM_ROOT, \"str\", \"text\")  # Raw bytes am_put(doc, AM_ROOT, \"bytes\", raw(10))  # Timestamp am_put(doc, AM_ROOT, \"time\", Sys.time())  # Counter am_put(doc, AM_ROOT, \"score\", am_counter(0)) am_counter_increment(doc, AM_ROOT, \"score\", 10) value <- am_get(doc, AM_ROOT, \"score\")  # Explicit type constructors am_put(doc, AM_ROOT, \"items\", am_list()) # Empty list am_put(doc, AM_ROOT, \"config\", am_map()) # Empty map am_put(doc, AM_ROOT, \"notes\", am_text()) # Text object"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"synchronization-high-level","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Synchronization (High-Level)","title":"Quick Reference","text":"","code":"# Bidirectional sync (auto-converge) # Documents are modified in place rounds <- am_sync(doc1, doc2) cat(\"Converged in\", rounds, \"rounds\\n\")  # One-way merge am_merge(doc1, doc2) # Merge doc2 into doc1"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"synchronization-low-level","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Synchronization (Low-Level)","title":"Quick Reference","text":"","code":"# Create sync state sync_state <- am_sync_state_new()  # Encode/decode messages msg <- am_sync_encode(doc, sync_state) am_sync_decode(doc, sync_state, msg)  # Manual sync loop repeat {   msg1 <- am_sync_encode(doc1, sync1)   if (is.null(msg1)) {     break   }   am_sync_decode(doc2, sync2, msg1)    msg2 <- am_sync_encode(doc2, sync2)   if (is.null(msg2)) {     break   }   am_sync_decode(doc1, sync1, msg2) }"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"history-changes","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"History & Changes","title":"Quick Reference","text":"","code":"# Get heads heads <- am_get_heads(doc)  # Get changes changes <- am_get_changes(doc, NULL) # All changes changes <- am_get_changes(doc, heads) # Since specific heads  # Apply changes am_apply_changes(doc, changes)  # Full history history <- am_get_history(doc)"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"conversion","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Conversion","title":"Quick Reference","text":"","code":"# R â†’ Automerge doc <- as_automerge(list(name = \"Alice\", age = 30L))  # Automerge â†’ R r_list <- from_automerge(doc) r_list <- as.list(doc)"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"pipe-friendly-style","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Pipe-Friendly Style","title":"Quick Reference","text":"","code":"doc <- am_create() |>   am_put(AM_ROOT, \"name\", \"Alice\") |>   am_put(AM_ROOT, \"age\", 30L) |>   am_commit(\"Initial data\")"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"file-operations","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"File Operations","title":"Quick Reference","text":"","code":"# Save to file writeBin(am_save(doc), \"document.automerge\")  # Load from file doc <- am_load(readBin(\"document.automerge\", \"raw\", 1e6))"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"constants","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Constants","title":"Quick Reference","text":"","code":"AM_ROOT # Root object (NULL) AM_OBJ_TYPE_LIST # \"list\" AM_OBJ_TYPE_MAP # \"map\" AM_OBJ_TYPE_TEXT # \"text\"  AM_MARK_EXPAND_NONE # \"none\" (mark doesn't expand at boundaries) AM_MARK_EXPAND_BEFORE # \"before\" (expands when text inserted before start) AM_MARK_EXPAND_AFTER # \"after\" (expands when text inserted after end) AM_MARK_EXPAND_BOTH # \"both\" (expands at both boundaries)"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"getting-help","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Getting Help","title":"Quick Reference","text":"","code":"# Function help ?am_create ?am_put ?am_sync  # Package help ?automerge help(package = \"automerge\")  # Vignettes vignette(\"automerge\", \"automerge\") vignette(\"crdt-concepts\", \"automerge\") vignette(\"sync-protocol\", \"automerge\") vignette(package = \"automerge\") # List all"},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"system-requirements","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"System Requirements","title":"Quick Reference","text":"R >= 4.2 Rust >= 1.89.0 (https://rustup.rs/) CMake >= 3.25 (included Rtools43+ Windows) : Install automerge-c (UTF-32 character indexing) system-wide skip build","code":""},{"path":"http://shikokuchuo.net/automerge-r/articles/very-quick-reference.html","id":"resources","dir":"Articles","previous_headings":"Automerge R Package Quick Reference","what":"Resources","title":"Quick Reference","text":"Package site: https://shikokuchuo.net/automerge-r/ Automerge docs: https://automerge.org/ Binary format: https://automerge.org/automerge-binary-format-spec/ CRDT research: https://crdt.tech/ Note: quick reference. See full vignettes detailed examples explanations.","code":""},{"path":"http://shikokuchuo.net/automerge-r/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Charlie Gao. Author, maintainer. . Copyright holder, funder.","code":""},{"path":"http://shikokuchuo.net/automerge-r/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Gao C (2025). automerge: R Bindings Automerge CRDT Library. R package version 0.1.0.9000, https://github.com/shikokuchuo/automerge-r.","code":"@Manual{,   title = {automerge: R Bindings for Automerge CRDT Library},   author = {Charlie Gao},   year = {2025},   note = {R package version 0.1.0.9000},   url = {https://github.com/shikokuchuo/automerge-r}, }"},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"automerge","dir":"","previous_headings":"","what":"R Bindings for Automerge CRDT Library","title":"R Bindings for Automerge CRDT Library","text":"Conflict-free data synchronization R automerge brings Automerge CRDTs (Conflict-free Replicated Data Types) R, enabling automatic merging concurrent changes across distributed systems without conflicts. Work offline, collaborate real-time, sync across platformsâ€”changes merge automatically.","code":""},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"why-automerge","dir":"","previous_headings":"","what":"Why Automerge?","title":"R Bindings for Automerge CRDT Library","text":"Traditional approaches distributed data either require central server coordinate changes force developers write complex conflict resolution logic. Automergeâ€™s CRDT technology automatically merges concurrent changes mathematical guarantees, eliminating need coordination making distributed systems dramatically simpler.","code":""},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"quick-example","dir":"","previous_headings":"","what":"Quick Example","title":"R Bindings for Automerge CRDT Library","text":"","code":"library(automerge)  # Two researchers working independently alice <- am_create() alice$experiment <- \"trial_001\" alice$temperature <- 23.5 am_commit(alice, \"Alice's data\")  bob <- am_create() bob$experiment <- \"trial_002\" bob$humidity <- 65 am_commit(bob, \"Bob's data\")  # Later, sync with zero conflicts am_sync(alice, bob) alice #> <Automerge Document> #> Actor: f13c3435c37f00870ad5006bd804566d  #> Root keys: 3  #> Keys: experiment, humidity, temperature bob #> <Automerge Document> #> Actor: 492d96612922d06aa4ca653d14f3bb0a  #> Root keys: 3  #> Keys: experiment, humidity, temperature"},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"key-features","dir":"","previous_headings":"","what":"Key Features","title":"R Bindings for Automerge CRDT Library","text":"Familiar R syntax: Work CRDT documents like regular R lists Rich data types: Maps, lists, text objects, counters, timestamps Collaborative text editing: Cursors marks rich text applications Bidirectional sync: High-level am_sync() low-level protocol access Offline-first: Make changes offline, merge connected Cross-platform: Interoperates JavaScript Automerge implementations Zero dependencies: base R required runtime","code":""},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Bindings for Automerge CRDT Library","text":"Building source requires Rust >= 1.89.0 (rustup.rs) CMake >= 3.25 (included Rtools43+ Windows).","code":"install.packages(\"automerge\", repos = \"https://shikokuchuo.r-universe.dev\")"},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"R Bindings for Automerge CRDT Library","text":"Getting Started: Introduction basic usage Quick Reference: Function reference organized task CRDT Concepts: Understanding conflict-free data types Sync Protocol: Low-level synchronization details Function Reference: Complete API documentation","code":""},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"status","dir":"","previous_headings":"","what":"Status","title":"R Bindings for Automerge CRDT Library","text":"Active Development: package initial development functionality may change time","code":""},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"external-resources","dir":"","previous_headings":"","what":"External Resources","title":"R Bindings for Automerge CRDT Library","text":"Automerge Website - Official Automerge documentation guides Automerge GitHub - Automerge source code Local-first software - philosophy behind Automerge","code":""},{"path":"http://shikokuchuo.net/automerge-r/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"R Bindings for Automerge CRDT Library","text":"MIT License. See LICENSE details. package includes automerge-c library (also MIT licensed)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_apply_changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply changes to a document â€” am_apply_changes","title":"Apply changes to a document â€” am_apply_changes","text":"Applies list changes (obtained am_get_changes()) document. useful manually syncing changes applying changes received custom network protocol.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_apply_changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply changes to a document â€” am_apply_changes","text":"","code":"am_apply_changes(doc, changes)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_apply_changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Apply changes to a document â€” am_apply_changes","text":"doc Automerge document changes list raw vectors (serialized changes) am_get_changes()","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_apply_changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Apply changes to a document â€” am_apply_changes","text":"document doc (invisibly, chaining)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_apply_changes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Apply changes to a document â€” am_apply_changes","text":"","code":"# Create two documents doc1 <- am_create() doc2 <- am_create()  # Make changes in doc1 am_put(doc1, AM_ROOT, \"x\", 1) am_commit(doc1)  # Get changes and apply to doc2 changes <- am_get_changes(doc1, NULL) am_apply_changes(doc2, changes)  # Now doc2 has the same data as doc1"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_commit.html","id":null,"dir":"Reference","previous_headings":"","what":"Commit pending changes â€” am_commit","title":"Commit pending changes â€” am_commit","text":"Commits pending operations current transaction, creating new change document's history. Commits can include optional message (like git commit message) timestamp.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_commit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Commit pending changes â€” am_commit","text":"","code":"am_commit(doc, message = NULL, time = NULL)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_commit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Commit pending changes â€” am_commit","text":"doc Automerge document message Optional commit message (character string) time Optional timestamp (POSIXct). NULL, uses current time.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_commit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Commit pending changes â€” am_commit","text":"document doc (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_commit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Commit pending changes â€” am_commit","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"key\", \"value\") am_commit(doc, \"Add initial data\")  # Commit with specific timestamp am_commit(doc, \"Update\", Sys.time())"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Automerge counter â€” am_counter","title":"Create an Automerge counter â€” am_counter","text":"Creates counter value use Automerge. Counters CRDT types support conflict-free increment decrement operations.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Automerge counter â€” am_counter","text":"","code":"am_counter(value = 0L)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Automerge counter â€” am_counter","text":"value Initial counter value (default 0)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Automerge counter â€” am_counter","text":"am_counter object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Automerge counter â€” am_counter","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"score\", am_counter(0))"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter_increment.html","id":null,"dir":"Reference","previous_headings":"","what":"Increment a counter value â€” am_counter_increment","title":"Increment a counter value â€” am_counter_increment","text":"Increments Automerge counter specified delta. Counters CRDT types support concurrent increments multiple actors. Unlike regular integers, counter increments commutative conflict merged.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter_increment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Increment a counter value â€” am_counter_increment","text":"","code":"am_counter_increment(doc, obj, key, delta)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter_increment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Increment a counter value â€” am_counter_increment","text":"doc Automerge document obj Automerge object ID (map list), AM_ROOT document root key maps: character string key. lists: integer index (1-based) delta Integer value add counter (can negative)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter_increment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Increment a counter value â€” am_counter_increment","text":"document (invisibly), allowing chaining pipes","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter_increment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Increment a counter value â€” am_counter_increment","text":"delta can negative decrement counter.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_counter_increment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Increment a counter value â€” am_counter_increment","text":"","code":"# Counter in document root (map) doc <- am_create() doc$score <- am_counter(0) am_counter_increment(doc, AM_ROOT, \"score\", 10) doc$score  # 10 #> <Automerge Counter: 10 >  am_counter_increment(doc, AM_ROOT, \"score\", 5) doc$score  # 15 #> <Automerge Counter: 15 >  # Decrement with negative delta am_counter_increment(doc, AM_ROOT, \"score\", -3) doc$score  # 12 #> <Automerge Counter: 12 >  # Counter in a nested map doc$stats <- am_map(views = am_counter(0)) stats_obj <- doc$stats am_counter_increment(doc, stats_obj, \"views\", 100)  # Counter in a list (1-based indexing) doc$counters <- list(am_counter(0), am_counter(5)) counters_obj <- doc$counters am_counter_increment(doc, counters_obj, 1, 1)  # Increment first counter am_counter_increment(doc, counters_obj, 2, 2)  # Increment second counter"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new Automerge document â€” am_create","title":"Create a new Automerge document â€” am_create","text":"Creates new Automerge document optional custom actor ID. actor ID provided, random one generated.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new Automerge document â€” am_create","text":"","code":"am_create(actor_id = NULL)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new Automerge document â€” am_create","text":"actor_id Optional actor ID. Can : NULL (default) - Generate random actor ID Character string - Hex-encoded actor ID Raw vector - Binary actor ID bytes","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new Automerge document â€” am_create","text":"external pointer Automerge document class c(\"am_doc\", \"automerge\").","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_create.html","id":"thread-safety","dir":"Reference","previous_headings":"","what":"Thread Safety","title":"Create a new Automerge document â€” am_create","text":"automerge package thread-safe. access document multiple R threads concurrently. thread create document am_create() synchronize changes via am_sync_*() functions thread completion.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new Automerge document â€” am_create","text":"","code":"# Create document with random actor ID doc <- am_create()  # Create with custom hex actor ID doc2 <- am_create(\"0123456789abcdef0123456789abcdef\")  # Create with raw bytes actor ID actor_bytes <- as.raw(1:16) doc3 <- am_create(actor_bytes)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a cursor at a position in a text object â€” am_cursor","title":"Create a cursor at a position in a text object â€” am_cursor","text":"Cursors provide stable references positions within text objects automatically adjust text edited. enables features like maintaining selection positions across concurrent edits collaborative editing scenarios.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a cursor at a position in a text object â€” am_cursor","text":"","code":"am_cursor(obj, position)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a cursor at a position in a text object â€” am_cursor","text":"obj Automerge object ID (must text object) position Integer position text (0-based inter-character position)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a cursor at a position in a text object â€” am_cursor","text":"am_cursor object (external pointer) can used am_cursor_position() retrieve current position","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor.html","id":"indexing-convention","dir":"Reference","previous_headings":"","what":"Indexing Convention","title":"Create a cursor at a position in a text object â€” am_cursor","text":"Cursor positions use 0-based indexing (unlike list indices 1-based). positions specify locations characters, characters : Position 0 = first character Position 1 = 1st 2nd characters Position 5 = 5th character text \"Hello\": matches am_text_splice() behavior. Positions count Unicode code points (characters), bytes.","code":"H e l l o  0 1 2 3 4 5  <- positions (0-based, between characters)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a cursor at a position in a text object â€” am_cursor","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"text\", am_text(\"Hello World\")) text_obj <- am_get(doc, AM_ROOT, \"text\")  # Create cursor at position 5 (after \"Hello\", before \" \") cursor <- am_cursor(text_obj, 5)  # Modify text before cursor am_text_splice(text_obj, 0, 0, \"Hi \")  # Cursor position automatically adjusts new_pos <- am_cursor_position(text_obj, cursor) print(new_pos)  # 8 (cursor moved by 3 characters) #> [1] 8"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor_position.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the current position of a cursor â€” am_cursor_position","title":"Get the current position of a cursor â€” am_cursor_position","text":"Retrieves current position cursor within text object. position automatically adjusts text inserted deleted cursor's original position.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor_position.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the current position of a cursor â€” am_cursor_position","text":"","code":"am_cursor_position(obj, cursor)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor_position.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the current position of a cursor â€” am_cursor_position","text":"obj Automerge object ID (must text object) cursor am_cursor object created am_cursor()","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor_position.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the current position of a cursor â€” am_cursor_position","text":"Integer position (0-based inter-character position) cursor currently points. See am_cursor() indexing details.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_cursor_position.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the current position of a cursor â€” am_cursor_position","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"text\", am_text(\"Hello World\")) text_obj <- am_get(doc, AM_ROOT, \"text\")  # Create cursor cursor <- am_cursor(text_obj, 5)  # Get position pos <- am_cursor_position(text_obj, cursor) print(pos)  # 5 #> [1] 5"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete.html","id":null,"dir":"Reference","previous_headings":"","what":"Delete a key from a map or element from a list â€” am_delete","title":"Delete a key from a map or element from a list â€” am_delete","text":"Removes key-value pair map element list.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delete a key from a map or element from a list â€” am_delete","text":"","code":"am_delete(doc, obj, key)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delete a key from a map or element from a list â€” am_delete","text":"doc Automerge document obj Automerge object ID (nested object), AM_ROOT document root key maps: character string key delete. lists: numeric index (1-based, like R vectors) delete","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delete a key from a map or element from a list â€” am_delete","text":"document doc (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delete a key from a map or element from a list â€” am_delete","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"temp\", \"value\") am_delete(doc, AM_ROOT, \"temp\")"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Delete value at path â€” am_delete_path","title":"Delete value at path â€” am_delete_path","text":"Delete value Automerge document using path vector.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Delete value at path â€” am_delete_path","text":"","code":"am_delete_path(doc, path)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Delete value at path â€” am_delete_path","text":"doc Automerge document path Character vector, numeric vector, list mixed types specifying path value delete","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Delete value at path â€” am_delete_path","text":"document (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_delete_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Delete value at path â€” am_delete_path","text":"","code":"doc <- am_create() am_put_path(doc, c(\"user\", \"address\", \"city\"), \"NYC\") am_put_path(doc, c(\"user\", \"name\"), \"Alice\")  # Delete nested key am_delete_path(doc, c(\"user\", \"address\"))  # Address should be gone am_get_path(doc, c(\"user\", \"address\"))  # NULL #> NULL"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_fork.html","id":null,"dir":"Reference","previous_headings":"","what":"Fork an Automerge document â€” am_fork","title":"Fork an Automerge document â€” am_fork","text":"Creates fork Automerge document current heads specific point history. forked document shares history original fork point can diverge afterwards.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_fork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fork an Automerge document â€” am_fork","text":"","code":"am_fork(doc, heads = NULL)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_fork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fork an Automerge document â€” am_fork","text":"doc Automerge document heads Optional list change hashes fork specific point document's history. NULL (default) empty list, forks current heads. hash raw vector (32 bytes).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_fork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fork an Automerge document â€” am_fork","text":"new Automerge document (fork original)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_fork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fork an Automerge document â€” am_fork","text":"","code":"doc1 <- am_create() doc2 <- am_fork(doc1)  # Now doc1 and doc2 can diverge independently"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a value from an Automerge map or list â€” am_get","title":"Get a value from an Automerge map or list â€” am_get","text":"Retrieves value Automerge map list. Returns NULL key index exist.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a value from an Automerge map or list â€” am_get","text":"","code":"am_get(doc, obj, key)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a value from an Automerge map or list â€” am_get","text":"doc Automerge document obj Automerge object ID (nested object), AM_ROOT document root key maps: character string key. lists: numeric index (1-based). Returns NULL indices <= 0 beyond list length.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a value from an Automerge map or list â€” am_get","text":"value specified key/position, NULL found. Nested objects returned am_object instances.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a value from an Automerge map or list â€” am_get","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"name\", \"Alice\")  name <- am_get(doc, AM_ROOT, \"name\") print(name)  # \"Alice\" #> [1] \"Alice\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the actor ID of a document â€” am_get_actor","title":"Get the actor ID of a document â€” am_get_actor","text":"Returns actor ID Automerge document raw vector. actor ID uniquely identifies editing session created changes document.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the actor ID of a document â€” am_get_actor","text":"","code":"am_get_actor(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the actor ID of a document â€” am_get_actor","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the actor ID of a document â€” am_get_actor","text":"raw vector containing actor ID bytes","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the actor ID of a document â€” am_get_actor","text":"hex string representation, use am_get_actor_hex().","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the actor ID of a document â€” am_get_actor","text":"","code":"doc <- am_create() actor <- am_get_actor(doc)  # Use am_get_actor_hex() for display actor_hex <- am_get_actor_hex(doc) cat(\"Actor ID:\", actor_hex, \"\\n\") #> Actor ID: 08f1844a8a30c9e09a61866135207d77"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor_hex.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the actor ID as a hex string â€” am_get_actor_hex","title":"Get the actor ID as a hex string â€” am_get_actor_hex","text":"Returns actor ID Automerge document hex-encoded string. efficient converting raw bytes returned am_get_actor() using R-level string operations.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor_hex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the actor ID as a hex string â€” am_get_actor_hex","text":"","code":"am_get_actor_hex(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor_hex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the actor ID as a hex string â€” am_get_actor_hex","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor_hex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the actor ID as a hex string â€” am_get_actor_hex","text":"character string containing hex-encoded actor ID","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_actor_hex.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the actor ID as a hex string â€” am_get_actor_hex","text":"","code":"doc <- am_create() actor_hex <- am_get_actor_hex(doc) cat(\"Actor ID:\", actor_hex, \"\\n\") #> Actor ID: 8b627078198a8faad51ecd565b3e0551"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_change_by_hash.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a specific change by its hash â€” am_get_change_by_hash","title":"Get a specific change by its hash â€” am_get_change_by_hash","text":"Retrieves change document's history unique hash identifier. hash typically obtained am_get_heads() am_get_changes().","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_change_by_hash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a specific change by its hash â€” am_get_change_by_hash","text":"","code":"am_get_change_by_hash(doc, hash)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_change_by_hash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a specific change by its hash â€” am_get_change_by_hash","text":"doc Automerge document hash raw vector containing change hash (must exactly 32 bytes)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_change_by_hash.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a specific change by its hash â€” am_get_change_by_hash","text":"raw vector containing serialized change, NULL change hash found document.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_change_by_hash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a specific change by its hash â€” am_get_change_by_hash","text":"","code":"doc <- am_create() doc$key <- \"value\" am_commit(doc, \"Add key\")  # Get the current heads (change hashes) heads <- am_get_heads(doc) head_hash <- heads[[1]]  # Retrieve the change by its hash change <- am_get_change_by_hash(doc, head_hash) str(change)  # Raw vector #>  raw [1:70] 85 6f 4a 83 ..."},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Get changes since specified heads â€” am_get_changes","title":"Get changes since specified heads â€” am_get_changes","text":"Returns changes made document since specified heads. heads NULL, returns changes document's history.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get changes since specified heads â€” am_get_changes","text":"","code":"am_get_changes(doc, heads = NULL)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get changes since specified heads â€” am_get_changes","text":"doc Automerge document heads list raw vectors (change hashes) returned am_get_heads(), NULL get changes.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get changes since specified heads â€” am_get_changes","text":"list raw vectors, containing serialized change.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get changes since specified heads â€” am_get_changes","text":"Changes returned serialized raw vectors can transmitted network applied documents using am_apply_changes().","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get changes since specified heads â€” am_get_changes","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"x\", 1) am_commit(doc)  # Get all changes all_changes <- am_get_changes(doc, NULL) cat(\"Document has\", length(all_changes), \"change(s)\\n\") #> Document has 1 change(s)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes_added.html","id":null,"dir":"Reference","previous_headings":"","what":"Get changes in one document that are not in another â€” am_get_changes_added","title":"Get changes in one document that are not in another â€” am_get_changes_added","text":"Compares two documents returns changes exist doc2 doc1. useful determining changes need applied bring doc1 date doc2, implementing custom synchronization logic.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes_added.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get changes in one document that are not in another â€” am_get_changes_added","text":"","code":"am_get_changes_added(doc1, doc2)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes_added.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get changes in one document that are not in another â€” am_get_changes_added","text":"doc1 Automerge document (base/reference document) doc2 Automerge document (comparison document)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes_added.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get changes in one document that are not in another â€” am_get_changes_added","text":"list raw vectors, vector serialized change exists doc2 doc1. Returns empty list doc1 already contains changes doc2.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_changes_added.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get changes in one document that are not in another â€” am_get_changes_added","text":"","code":"# Create two independent documents doc1 <- am_create() doc1$x <- 1 am_commit(doc1, \"Add x\")  doc2 <- am_create() doc2$y <- 2 am_commit(doc2, \"Add y\")  # Find changes in doc2 that aren't in doc1 changes <- am_get_changes_added(doc1, doc2) length(changes)  # 1 change #> [1] 1  # Apply those changes to doc1 am_apply_changes(doc1, changes)  # Now doc1 has both x and y names(doc1)  # \"x\" \"y\" #> [1] \"x\" \"y\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_heads.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the current heads of a document â€” am_get_heads","title":"Get the current heads of a document â€” am_get_heads","text":"Returns current \"heads\" document - hashes recent changes. identify current state document can used history operations.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_heads.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the current heads of a document â€” am_get_heads","text":"","code":"am_get_heads(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_heads.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the current heads of a document â€” am_get_heads","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_heads.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the current heads of a document â€” am_get_heads","text":"list raw vectors, containing change hash. Usually one head, concurrent edits may multiple heads merged subsequent commit.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_heads.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the current heads of a document â€” am_get_heads","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"x\", 1) am_commit(doc)  heads <- am_get_heads(doc) cat(\"Document has\", length(heads), \"head(s)\\n\") #> Document has 1 head(s)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_history.html","id":null,"dir":"Reference","previous_headings":"","what":"Get document history â€” am_get_history","title":"Get document history â€” am_get_history","text":"Returns full change history document list change metadata. provides simpler interface am_get_changes() examining document history without needing work serialized changes directly.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_history.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get document history â€” am_get_history","text":"","code":"am_get_history(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_history.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get document history â€” am_get_history","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_history.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get document history â€” am_get_history","text":"list raw vectors (serialized changes), one change document's history, chronological order.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_history.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get document history â€” am_get_history","text":"Note: future implementation add detailed change introspection functions extract metadata like commit messages, timestamps, actor IDs, etc.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_history.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get document history â€” am_get_history","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"x\", 1) am_commit(doc, \"Initial\") am_put(doc, AM_ROOT, \"x\", 2) am_commit(doc, \"Update\")  history <- am_get_history(doc) cat(\"Document history contains\", length(history), \"change(s)\\n\") #> Document history contains 2 change(s)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_last_local_change.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the last change made by the local actor â€” am_get_last_local_change","title":"Get the last change made by the local actor â€” am_get_last_local_change","text":"Returns recent change created document's actor. Useful tracking local changes implementing undo/redo functionality.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_last_local_change.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the last change made by the local actor â€” am_get_last_local_change","text":"","code":"am_get_last_local_change(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_last_local_change.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the last change made by the local actor â€” am_get_last_local_change","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_last_local_change.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the last change made by the local actor â€” am_get_last_local_change","text":"raw vector containing serialized change, NULL local changes made.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_last_local_change.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the last change made by the local actor â€” am_get_last_local_change","text":"","code":"doc <- am_create()  # Initially, no local changes am_get_last_local_change(doc)  # NULL #> NULL  # Make a change doc$key <- \"value\" am_commit(doc, \"Add key\")  # Now we have a local change change <- am_get_last_local_change(doc) str(change)  # Raw vector #>  raw [1:70] 85 6f 4a 83 ..."},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Navigate deep structures with path â€” am_get_path","title":"Navigate deep structures with path â€” am_get_path","text":"Get value Automerge document using path vector. path can contain character keys (maps), numeric indices (lists, 1-based), mix .","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Navigate deep structures with path â€” am_get_path","text":"","code":"am_get_path(doc, path)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Navigate deep structures with path â€” am_get_path","text":"doc Automerge document path Character vector, numeric vector, list mixed types specifying path navigate","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Navigate deep structures with path â€” am_get_path","text":"value path, NULL found","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_get_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Navigate deep structures with path â€” am_get_path","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"user\", list(   name = \"Alice\",   address = list(city = \"NYC\", zip = 10001L) ))  # Navigate to nested value am_get_path(doc, c(\"user\", \"address\", \"city\"))  # \"NYC\" #> [1] \"NYC\"  # Mixed navigation (map key, then list index) doc$users <- list(   list(name = \"Bob\"),   list(name = \"Carol\") ) am_get_path(doc, list(\"users\", 1, \"name\"))  # \"Bob\" #> [1] \"Bob\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_insert.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert a value into an Automerge list â€” am_insert","title":"Insert a value into an Automerge list â€” am_insert","text":"alias am_put() insert semantics lists. lists, am_put() numeric index replaces element index, am_insert() shifts elements make room.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_insert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert a value into an Automerge list â€” am_insert","text":"","code":"am_insert(doc, obj, pos, value)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_insert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert a value into an Automerge list â€” am_insert","text":"doc Automerge document obj Automerge object ID (must list) pos Numeric index (1-based, like R vectors) insert, \"end\" append value value insert","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_insert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert a value into an Automerge list â€” am_insert","text":"document doc (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_insert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert a value into an Automerge list â€” am_insert","text":"","code":"doc <- am_create() # Create a list and get it am_put(doc, AM_ROOT, \"items\", AM_OBJ_TYPE_LIST) items <- am_get(doc, AM_ROOT, \"items\")  # Insert items am_insert(doc, items, \"end\", \"first\") am_insert(doc, items, \"end\", \"second\")"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all keys from an Automerge map â€” am_keys","title":"Get all keys from an Automerge map â€” am_keys","text":"Returns character vector keys map.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all keys from an Automerge map â€” am_keys","text":"","code":"am_keys(doc, obj)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all keys from an Automerge map â€” am_keys","text":"doc Automerge document obj Automerge object ID (must map), AM_ROOT document root","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all keys from an Automerge map â€” am_keys","text":"Character vector keys (empty map empty)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_keys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all keys from an Automerge map â€” am_keys","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"a\", 1) am_put(doc, AM_ROOT, \"b\", 2)  keys <- am_keys(doc, AM_ROOT) print(keys)  # c(\"a\", \"b\") #> [1] \"a\" \"b\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_length.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the length of an Automerge map or list â€” am_length","title":"Get the length of an Automerge map or list â€” am_length","text":"Returns number key-value pairs map elements list.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the length of an Automerge map or list â€” am_length","text":"","code":"am_length(doc, obj)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the length of an Automerge map or list â€” am_length","text":"doc Automerge document obj Automerge object ID, AM_ROOT document root","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_length.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the length of an Automerge map or list â€” am_length","text":"Integer length/size","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the length of an Automerge map or list â€” am_length","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"a\", 1) am_put(doc, AM_ROOT, \"b\", 2)  len <- am_length(doc, AM_ROOT) print(len)  # 2 #> [1] 2"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Automerge list â€” am_list","title":"Create an Automerge list â€” am_list","text":"Creates R list explicit Automerge list type. Use need create empty list force list type interpretation.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Automerge list â€” am_list","text":"","code":"am_list(...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Automerge list â€” am_list","text":"... Elements include list","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Automerge list â€” am_list","text":"list class am_list_type","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Automerge list â€” am_list","text":"","code":"# Empty list (avoids ambiguity) am_list() #> list() #> attr(,\"class\") #> [1] \"am_list_type\" \"list\"          # Populated list am_list(\"a\", \"b\", \"c\") #> [[1]] #> [1] \"a\" #>  #> [[2]] #> [1] \"b\" #>  #> [[3]] #> [1] \"c\" #>  #> attr(,\"class\") #> [1] \"am_list_type\" \"list\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_load.html","id":null,"dir":"Reference","previous_headings":"","what":"Load an Automerge document from binary format â€” am_load","title":"Load an Automerge document from binary format â€” am_load","text":"Deserializes Automerge document standard binary format. binary format compatible across Automerge implementations (JavaScript, Rust, etc.).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_load.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Load an Automerge document from binary format â€” am_load","text":"","code":"am_load(data)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_load.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Load an Automerge document from binary format â€” am_load","text":"data raw vector containing serialized Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_load.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Load an Automerge document from binary format â€” am_load","text":"external pointer Automerge document class c(\"am_doc\", \"automerge\").","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_load.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Load an Automerge document from binary format â€” am_load","text":"","code":"# Create, save, and reload doc1 <- am_create() bytes <- am_save(doc1) doc2 <- am_load(bytes)  # Load from file if (FALSE) { # \\dontrun{ doc <- am_load(readBin(\"document.automerge\", \"raw\", 1e7)) } # }"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Automerge map â€” am_map","title":"Create an Automerge map â€” am_map","text":"Creates R list explicit Automerge map type. Use need create empty map force map type interpretation.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Automerge map â€” am_map","text":"","code":"am_map(...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Automerge map â€” am_map","text":"... Named elements include map","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Automerge map â€” am_map","text":"named list class am_map_type","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_map.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Automerge map â€” am_map","text":"","code":"# Empty map (avoids ambiguity) am_map() #> list() #> attr(,\"class\") #> [1] \"am_map_type\" \"list\"         # Populated map am_map(key1 = \"value1\", key2 = \"value2\") #> $key1 #> [1] \"value1\" #>  #> $key2 #> [1] \"value2\" #>  #> attr(,\"class\") #> [1] \"am_map_type\" \"list\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a mark on a text range â€” am_mark_create","title":"Create a mark on a text range â€” am_mark_create","text":"Marks attach metadata formatting information range text. Unlike simple annotations, marks CRDT-aware merge correctly across concurrent edits.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a mark on a text range â€” am_mark_create","text":"","code":"am_mark_create(obj, start, end, name, value, expand = AM_MARK_EXPAND_NONE)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a mark on a text range â€” am_mark_create","text":"obj Automerge object ID (must text object) start Integer start position (0-based inter-character position, inclusive) end Integer end position (0-based inter-character position, exclusive) name Character string identifying mark (e.g., \"bold\", \"comment\") value mark's value (Automerge-compatible type: NULL, logical, integer, numeric, character, raw, POSIXct, am_counter) expand Character string controlling mark expansion behavior text inserted boundaries. Options: \"none\" Mark expand (default) \"\" Mark expands include text inserted start \"\" Mark expands include text inserted end \"\" Mark expands directions Use constants AM_MARK_EXPAND_NONE, AM_MARK_EXPAND_BEFORE, AM_MARK_EXPAND_AFTER, AM_MARK_EXPAND_BOTH.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a mark on a text range â€” am_mark_create","text":"text object obj (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":"indexing-convention","dir":"Reference","previous_headings":"","what":"Indexing Convention","title":"Create a mark on a text range â€” am_mark_create","text":"Mark positions use 0-based indexing (unlike list indices 1-based). Positions specify locations characters. range [start, end) includes start excludes end. text \"Hello\": Marking positions 0 5 marks 5 characters. Marking 0 3 marks \"Hel\". Positions count Unicode code points (characters), bytes.","code":"H e l l o  0 1 2 3 4 5  <- positions (0-based, between characters)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":"expand-behavior","dir":"Reference","previous_headings":"","what":"Expand Behavior","title":"Create a mark on a text range â€” am_mark_create","text":"expand parameter controls happens text inserted exactly mark boundaries: \"none\": New text never included mark \"\": Text inserted start included \"\": Text inserted end included \"\": Text inserted either boundary included","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_mark_create.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a mark on a text range â€” am_mark_create","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"text\", am_text(\"Hello World\")) text_obj <- am_get(doc, AM_ROOT, \"text\")  # Mark \"Hello\" as bold (positions 0-4, characters 0-4) am_mark_create(text_obj, 0, 5, \"bold\", TRUE)  # Mark \"World\" as italic with expansion am_mark_create(text_obj, 6, 11, \"italic\", TRUE,                expand = AM_MARK_EXPAND_BOTH)  # Get all marks marks <- am_marks(text_obj) print(marks) #> [[1]] #> [[1]]$name #> [1] \"bold\" #>  #> [[1]]$value #> [1] TRUE #>  #> [[1]]$start #> [1] 0 #>  #> [[1]]$end #> [1] 5 #>  #>  #> [[2]] #> [[2]]$name #> [1] \"italic\" #>  #> [[2]]$value #> [1] TRUE #>  #> [[2]]$start #> [1] 6 #>  #> [[2]]$end #> [1] 11 #>  #>"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all marks in a text object â€” am_marks","title":"Get all marks in a text object â€” am_marks","text":"Retrieves marks (formatting/metadata annotations) present text object specific document state.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all marks in a text object â€” am_marks","text":"","code":"am_marks(obj)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all marks in a text object â€” am_marks","text":"obj Automerge object ID (must text object)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all marks in a text object â€” am_marks","text":"list marks, mark list fields: name Character string identifying mark value mark's value (various types supported) start Integer start position (0-based inter-character position, inclusive) end Integer end position (0-based inter-character position, exclusive) Returns empty list marks present. See am_mark_create() indexing details.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all marks in a text object â€” am_marks","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"text\", am_text(\"Hello World\")) text_obj <- am_get(doc, AM_ROOT, \"text\")  am_mark_create(text_obj, 0, 5, \"bold\", TRUE) am_mark_create(text_obj, 6, 11, \"italic\", TRUE)  marks <- am_marks(text_obj) print(marks) #> [[1]] #> [[1]]$name #> [1] \"bold\" #>  #> [[1]]$value #> [1] TRUE #>  #> [[1]]$start #> [1] 0 #>  #> [[1]]$end #> [1] 5 #>  #>  #> [[2]] #> [[2]]$name #> [1] \"italic\" #>  #> [[2]]$value #> [1] TRUE #>  #> [[2]]$start #> [1] 6 #>  #> [[2]]$end #> [1] 11 #>  #>  # List of 2 marks with name, value, start, end"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks_at.html","id":null,"dir":"Reference","previous_headings":"","what":"Get marks at a specific position â€” am_marks_at","title":"Get marks at a specific position â€” am_marks_at","text":"Retrieves marks include specific position text object. function efficiently filters marks C level, avoiding overhead converting marks R objects.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks_at.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get marks at a specific position â€” am_marks_at","text":"","code":"am_marks_at(obj, position)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks_at.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get marks at a specific position â€” am_marks_at","text":"obj Automerge object ID (must text object) position Integer position (0-based inter-character position) query. See am_mark_create() indexing details.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks_at.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get marks at a specific position â€” am_marks_at","text":"list marks include specified position. Returns empty list marks cover position.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_marks_at.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get marks at a specific position â€” am_marks_at","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"text\", am_text(\"Hello World\")) text_obj <- am_get(doc, AM_ROOT, \"text\")  am_mark_create(text_obj, 0, 5, \"bold\", TRUE) am_mark_create(text_obj, 2, 7, \"underline\", TRUE)  # Get marks at position 3 (inside \"Hello\") marks_at_3 <- am_marks_at(text_obj, 3) print(marks_at_3) #> [[1]] #> [[1]]$name #> [1] \"bold\" #>  #> [[1]]$value #> [1] TRUE #>  #> [[1]]$start #> [1] 0 #>  #> [[1]]$end #> [1] 5 #>  #>  #> [[2]] #> [[2]]$name #> [1] \"underline\" #>  #> [[2]]$value #> [1] TRUE #>  #> [[2]]$start #> [1] 2 #>  #> [[2]]$end #> [1] 7 #>  #>  # List of 2 marks (both \"bold\" and \"underline\" include position 3)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_merge.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge changes from another document â€” am_merge","title":"Merge changes from another document â€” am_merge","text":"Merges changes another Automerge document one. one-way merge: changes flow doc, modified. bidirectional synchronization, use am_sync().","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_merge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge changes from another document â€” am_merge","text":"","code":"am_merge(doc, other)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_merge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge changes from another document â€” am_merge","text":"doc Target document (receive changes) Source document (provides changes)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_merge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge changes from another document â€” am_merge","text":"target document doc (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_merge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge changes from another document â€” am_merge","text":"","code":"doc1 <- am_create() doc2 <- am_create()  # Make changes in each document am_put(doc1, AM_ROOT, \"x\", 1) am_put(doc2, AM_ROOT, \"y\", 2)  # Merge doc2's changes into doc1 am_merge(doc1, doc2) # Now doc1 has both x and y"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put.html","id":null,"dir":"Reference","previous_headings":"","what":"Put a value into an Automerge map or list â€” am_put","title":"Put a value into an Automerge map or list â€” am_put","text":"Inserts updates value Automerge map list. function automatically dispatches appropriate operation based object type key/position type.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Put a value into an Automerge map or list â€” am_put","text":"","code":"am_put(doc, obj, key, value)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Put a value into an Automerge map or list â€” am_put","text":"doc Automerge document obj Automerge object ID (nested object), AM_ROOT document root key maps: character string key. lists: numeric index (1-based) \"end\" append value value store. Supported types: NULL - stores null Logical - stores boolean (must scalar) Integer - stores integer (must scalar) Numeric - stores double (must scalar) Character - stores string (must scalar) Raw - stores bytes AM_OBJ_TYPE_LIST/MAP/TEXT - creates nested object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Put a value into an Automerge map or list â€” am_put","text":"document doc (invisibly).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Put a value into an Automerge map or list â€” am_put","text":"","code":"doc <- am_create()  # Put values in root map (returns doc invisibly) am_put(doc, AM_ROOT, \"name\", \"Alice\") am_put(doc, AM_ROOT, \"age\", 30L) am_put(doc, AM_ROOT, \"active\", TRUE)  # Create nested list and retrieve it am_put(doc, AM_ROOT, \"items\", AM_OBJ_TYPE_LIST) items <- am_get(doc, AM_ROOT, \"items\")"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Set value at path â€” am_put_path","title":"Set value at path â€” am_put_path","text":"Set value Automerge document using path vector. Can optionally create intermediate objects automatically.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set value at path â€” am_put_path","text":"","code":"am_put_path(doc, path, value, create_intermediate = TRUE)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set value at path â€” am_put_path","text":"doc Automerge document path Character vector, numeric vector, list mixed types specifying path value value Value set path create_intermediate Logical. TRUE, creates intermediate maps needed. Default TRUE.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put_path.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set value at path â€” am_put_path","text":"document (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_put_path.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set value at path â€” am_put_path","text":"","code":"doc <- am_create()  # Create nested structure with automatic intermediate objects am_put_path(doc, c(\"user\", \"address\", \"city\"), \"Boston\") am_put_path(doc, c(\"user\", \"address\", \"zip\"), 02101L) am_put_path(doc, c(\"user\", \"name\"), \"Alice\")  # Verify am_get_path(doc, c(\"user\", \"address\", \"city\"))  # \"Boston\" #> [1] \"Boston\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_rollback.html","id":null,"dir":"Reference","previous_headings":"","what":"Roll back pending operations â€” am_rollback","title":"Roll back pending operations â€” am_rollback","text":"Cancels pending operations current transaction without committing . allows discard changes since last commit.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_rollback.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Roll back pending operations â€” am_rollback","text":"","code":"am_rollback(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_rollback.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Roll back pending operations â€” am_rollback","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_rollback.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Roll back pending operations â€” am_rollback","text":"document doc (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_rollback.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Roll back pending operations â€” am_rollback","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"key\", \"value\") # Changed my mind, discard the put am_rollback(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_save.html","id":null,"dir":"Reference","previous_headings":"","what":"Save an Automerge document to binary format â€” am_save","title":"Save an Automerge document to binary format â€” am_save","text":"Serializes Automerge document standard binary format, can saved disk transmitted network. binary format compatible across Automerge implementations (JavaScript, Rust, etc.).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_save.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save an Automerge document to binary format â€” am_save","text":"","code":"am_save(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_save.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save an Automerge document to binary format â€” am_save","text":"doc Automerge document (created am_create() am_load())","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_save.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save an Automerge document to binary format â€” am_save","text":"raw vector containing serialized document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_save.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save an Automerge document to binary format â€” am_save","text":"","code":"doc <- am_create() bytes <- am_save(doc)  # Save to file if (FALSE) { # \\dontrun{ writeBin(am_save(doc), \"document.automerge\") } # }"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_set_actor.html","id":null,"dir":"Reference","previous_headings":"","what":"Set the actor ID of a document â€” am_set_actor","title":"Set the actor ID of a document â€” am_set_actor","text":"Sets actor ID Automerge document. typically done making changes. Changing actor ID mid-session recommended can complicate change attribution.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_set_actor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set the actor ID of a document â€” am_set_actor","text":"","code":"am_set_actor(doc, actor_id)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_set_actor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set the actor ID of a document â€” am_set_actor","text":"doc Automerge document actor_id new actor ID. Can : NULL - Generate new random actor ID Character string - Hex-encoded actor ID Raw vector - Binary actor ID bytes","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_set_actor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set the actor ID of a document â€” am_set_actor","text":"document doc (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_set_actor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set the actor ID of a document â€” am_set_actor","text":"","code":"doc <- am_create()  # Set custom actor ID from hex string am_set_actor(doc, \"0123456789abcdef0123456789abcdef\")  # Generate new random actor ID am_set_actor(doc, NULL)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync.html","id":null,"dir":"Reference","previous_headings":"","what":"Bidirectional synchronization â€” am_sync","title":"Bidirectional synchronization â€” am_sync","text":"Automatically synchronizes two documents exchanging messages converge state. high-level convenience function handles entire sync protocol automatically.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bidirectional synchronization â€” am_sync","text":"","code":"am_sync(doc1, doc2)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bidirectional synchronization â€” am_sync","text":"doc1 First Automerge document doc2 Second Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bidirectional synchronization â€” am_sync","text":"integer indicating number sync rounds completed (invisibly). documents modified place include 's changes.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bidirectional synchronization â€” am_sync","text":"function exchanges sync messages back forth two documents sides report messages send (am_sync_encode() returns NULL). Automerge sync protocol mathematically guaranteed converge.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bidirectional synchronization â€” am_sync","text":"","code":"# Create two documents with different changes doc1 <- am_create() doc2 <- am_create()  # Make changes in each document am_put(doc1, AM_ROOT, \"x\", 1) am_put(doc2, AM_ROOT, \"y\", 2)  # Synchronize them (documents modified in place) rounds <- am_sync(doc1, doc2) cat(\"Synced in\", rounds, \"rounds\\n\") #> Synced in 4 rounds  # Now both documents have both x and y"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_decode.html","id":null,"dir":"Reference","previous_headings":"","what":"Receive and apply a sync message â€” am_sync_decode","title":"Receive and apply a sync message â€” am_sync_decode","text":"Receives synchronization message peer applies changes local document. updates document sync state reflect received changes.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_decode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Receive and apply a sync message â€” am_sync_decode","text":"","code":"am_sync_decode(doc, sync_state, message)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_decode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Receive and apply a sync message â€” am_sync_decode","text":"doc Automerge document sync_state sync state object (created am_sync_state_new()) message raw vector containing encoded sync message","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_decode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Receive and apply a sync message â€” am_sync_decode","text":"document doc (invisibly, chaining)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_decode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Receive and apply a sync message â€” am_sync_decode","text":"","code":"doc <- am_create() sync_state <- am_sync_state_new()  # Receive message from peer # message <- ... (received from network) # am_sync_decode(doc, sync_state, message)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_encode.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a sync message â€” am_sync_encode","title":"Generate a sync message â€” am_sync_encode","text":"Generates synchronization message send peer. message contains changes peer needs bring document date .","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_encode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a sync message â€” am_sync_encode","text":"","code":"am_sync_encode(doc, sync_state)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_encode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a sync message â€” am_sync_encode","text":"doc Automerge document sync_state sync state object (created am_sync_state_new())","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_encode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a sync message â€” am_sync_encode","text":"raw vector containing encoded sync message, NULL message needs sent.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_encode.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a sync message â€” am_sync_encode","text":"function returns NULL, means messages send (synchronization complete side).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_encode.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a sync message â€” am_sync_encode","text":"","code":"doc <- am_create() sync_state <- am_sync_state_new()  # Generate first sync message msg <- am_sync_encode(doc, sync_state) if (!is.null(msg)) {   # Send msg to peer... } #> NULL"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_state_new.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new sync state â€” am_sync_state_new","title":"Create a new sync state â€” am_sync_state_new","text":"Creates new synchronization state managing communication peer. sync state tracks changes sent received, enabling efficient incremental synchronization.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_state_new.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new sync state â€” am_sync_state_new","text":"","code":"am_sync_state_new()"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_state_new.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new sync state â€” am_sync_state_new","text":"external pointer sync state class \"am_syncstate\".","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_state_new.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a new sync state â€” am_sync_state_new","text":"IMPORTANT: Sync state document-independent. sync state used across multiple sync message exchanges specific peer. document passed separately am_sync_encode() am_sync_decode().","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_sync_state_new.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new sync state â€” am_sync_state_new","text":"","code":"# Create two documents doc1 <- am_create() doc2 <- am_create()  # Create sync states for each peer sync1 <- am_sync_state_new() sync2 <- am_sync_state_new()  # Use with am_sync_encode() and am_sync_decode()"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an Automerge text object â€” am_text","title":"Create an Automerge text object â€” am_text","text":"Creates text object collaborative character-level editing. Unlike regular strings (use last-write-wins semantics), text objects support character-level CRDT merging concurrent edits, cursor stability, marks/formatting.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an Automerge text object â€” am_text","text":"","code":"am_text(initial = \"\")"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an Automerge text object â€” am_text","text":"initial Initial text content (default \"\")","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an Automerge text object â€” am_text","text":"character vector class am_text_type","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create an Automerge text object â€” am_text","text":"Use text objects collaborative document editing. Use regular strings metadata, labels, IDs (99\\","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create an Automerge text object â€” am_text","text":"","code":"# Empty text object am_text() #> [1] \"\" #> attr(,\"class\") #> [1] \"am_text_type\" \"character\"     # Text with initial content am_text(\"Hello, World!\") #> [1] \"Hello, World!\" #> attr(,\"class\") #> [1] \"am_text_type\" \"character\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_get.html","id":null,"dir":"Reference","previous_headings":"","what":"Get text from a text object â€” am_text_get","title":"Get text from a text object â€” am_text_get","text":"Retrieve full text content text object string.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_get.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get text from a text object â€” am_text_get","text":"","code":"am_text_get(text_obj)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_get.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get text from a text object â€” am_text_get","text":"text_obj Automerge text object ID","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_get.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get text from a text object â€” am_text_get","text":"Character string full text","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_get.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get text from a text object â€” am_text_get","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"doc\", am_text(\"Hello\")) text_obj <- am_get(doc, AM_ROOT, \"doc\")  text <- am_text_get(text_obj) print(text)  # \"Hello\" #> [1] \"Hello\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_splice.html","id":null,"dir":"Reference","previous_headings":"","what":"Splice text in a text object â€” am_text_splice","title":"Splice text in a text object â€” am_text_splice","text":"Insert delete characters text object. primary way edit text CRDT objects.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_splice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Splice text in a text object â€” am_text_splice","text":"","code":"am_text_splice(text_obj, pos, del_count, text)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_splice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Splice text in a text object â€” am_text_splice","text":"text_obj Automerge text object ID pos Character position start splice (0-based inter-character position) del_count Number characters delete (counts Unicode code points) text Text insert","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_splice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Splice text in a text object â€” am_text_splice","text":"text object text_obj (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_splice.html","id":"indexing-convention","dir":"Reference","previous_headings":"","what":"Indexing Convention","title":"Splice text in a text object â€” am_text_splice","text":"Text positions use 0-based indexing (unlike list indices 1-based). positions specify locations characters, characters : Position 0 = first character Position 1 = 1st 2nd characters Position 5 = 5th character text \"Hello\": Positions count Unicode code points (characters), bytes. emoji \"ðŸ˜€\" counts 1 character, matching R's nchar() behavior.","code":"H e l l o  0 1 2 3 4 5  <- positions (0-based, between characters)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_text_splice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Splice text in a text object â€” am_text_splice","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"doc\", am_text(\"Hello\")) text_obj <- am_get(doc, AM_ROOT, \"doc\")  # Insert \" World\" at position 5 (after \"Hello\") am_text_splice(text_obj, 5, 0, \" World\")  # Get the full text am_text_get(text_obj)  # \"Hello World\" #> [1] \"Hello World\"  # Works naturally with multibyte characters am_put(doc, AM_ROOT, \"emoji\", am_text(\"\")) text_obj2 <- am_get(doc, AM_ROOT, \"emoji\") am_text_splice(text_obj2, 0, 0, \"HelloðŸ˜€\") # Position 5 is the emoji (character index, not bytes) am_text_splice(text_obj2, 6, 0, \"World\") am_text_get(text_obj2)  # \"HelloðŸ˜€World\" #> [1] \"HelloðŸ˜€World\""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Get all values from a map or list â€” am_values","title":"Get all values from a map or list â€” am_values","text":"Returns values Automerge map list R list.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get all values from a map or list â€” am_values","text":"","code":"am_values(doc, obj)"},{"path":"http://shikokuchuo.net/automerge-r/reference/am_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get all values from a map or list â€” am_values","text":"doc Automerge document obj Automerge object ID, AM_ROOT document root","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get all values from a map or list â€” am_values","text":"R list values","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/am_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get all values from a map or list â€” am_values","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"a\", 1) am_put(doc, AM_ROOT, \"b\", 2) am_put(doc, AM_ROOT, \"c\", 3)  values <- am_values(doc, AM_ROOT) print(values)  # list(1, 2, 3) #> [[1]] #> [1] 1 #>  #> [[2]] #> [1] 2 #>  #> [[3]] #> [1] 3 #>"},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert document root to R list â€” as.list.am_doc","title":"Convert document root to R list â€” as.list.am_doc","text":"Recursively converts root Automerge document standard R list. Maps become named lists, lists become unnamed lists, nested objects recursively converted.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert document root to R list â€” as.list.am_doc","text":"","code":"# S3 method for class 'am_doc' as.list(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert document root to R list â€” as.list.am_doc","text":"x Automerge document ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert document root to R list â€” as.list.am_doc","text":"Named list document contents","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_doc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert document root to R list â€” as.list.am_doc","text":"","code":"doc <- am_create() doc$name <- \"Alice\" doc$age <- 30L  as.list(doc)  # list(name = \"Alice\", age = 30L) #> $age #> [1] 30 #>  #> $name #> [1] \"Alice\" #>"},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Automerge list to R list â€” as.list.am_list","title":"Convert Automerge list to R list â€” as.list.am_list","text":"Recursively converts Automerge list unnamed R list.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Automerge list to R list â€” as.list.am_list","text":"","code":"# S3 method for class 'am_list' as.list(x, doc = NULL, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Automerge list to R list â€” as.list.am_list","text":"x Automerge list object doc document containing object (automatically provided) ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Automerge list to R list â€” as.list.am_list","text":"Unnamed list","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Automerge map to R list â€” as.list.am_map","title":"Convert Automerge map to R list â€” as.list.am_map","text":"Recursively converts Automerge map named R list.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Automerge map to R list â€” as.list.am_map","text":"","code":"# S3 method for class 'am_map' as.list(x, doc = NULL, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Automerge map to R list â€” as.list.am_map","text":"x Automerge map object doc document containing object (automatically provided) ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Automerge map to R list â€” as.list.am_map","text":"Named list","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_text.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Automerge text to character string â€” as.list.am_text","title":"Convert Automerge text to character string â€” as.list.am_text","text":"Returns text content character string.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Automerge text to character string â€” as.list.am_text","text":"","code":"# S3 method for class 'am_text' as.list(x, doc = NULL, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Automerge text to character string â€” as.list.am_text","text":"x Automerge text object doc document containing object (automatically provided) ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as.list.am_text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Automerge text to character string â€” as.list.am_text","text":"Character string","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as_automerge.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert R list to Automerge document â€” as_automerge","title":"Convert R list to Automerge document â€” as_automerge","text":"Converts R list Automerge document. leverages recursive conversion built am_put() Phase 3, allowing nested structures created single call.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as_automerge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert R list to Automerge document â€” as_automerge","text":"","code":"as_automerge(x, doc = NULL, actor_id = NULL)"},{"path":"http://shikokuchuo.net/automerge-r/reference/as_automerge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert R list to Automerge document â€” as_automerge","text":"x R list, vector, scalar value convert doc Optional existing Automerge document. NULL, creates new one. actor_id Optional actor ID new documents (raw bytes hex string)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as_automerge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert R list to Automerge document â€” as_automerge","text":"Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/as_automerge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert R list to Automerge document â€” as_automerge","text":"","code":"# Convert nested list to Automerge data <- list(   name = \"Alice\",   age = 30L,   scores = list(85, 90, 95),   metadata = list(     created = Sys.time(),     tags = list(\"user\", \"active\")   ) )  doc <- as_automerge(data) doc[[\"name\"]]  # \"Alice\" #> [1] \"Alice\" doc[[\"age\"]]   # 30L #> [1] 30"},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-constants.html","id":null,"dir":"Reference","previous_headings":"","what":"Automerge Constants â€” automerge-constants","title":"Automerge Constants â€” automerge-constants","text":"Constants used throughout automerge package object types, root references, mark expansion modes.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-constants.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automerge Constants â€” automerge-constants","text":"","code":"AM_ROOT  AM_OBJ_TYPE_LIST  AM_OBJ_TYPE_MAP  AM_OBJ_TYPE_TEXT  AM_MARK_EXPAND_NONE  AM_MARK_EXPAND_BEFORE  AM_MARK_EXPAND_AFTER  AM_MARK_EXPAND_BOTH"},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-constants.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Automerge Constants â€” automerge-constants","text":"object class NULL length 0. object class am_obj_type length 1. object class am_obj_type length 1. object class am_obj_type length 1. object class character length 1. object class character length 1. object class character length 1. object class character length 1.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-constants.html","id":"root-object","dir":"Reference","previous_headings":"","what":"Root Object","title":"Automerge Constants â€” automerge-constants","text":"AM_ROOT Reference root object Automerge document. Use obj parameter operating top-level map. Value NULL maps C API's AM_ROOT.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-constants.html","id":"object-types","dir":"Reference","previous_headings":"","what":"Object Types","title":"Automerge Constants â€” automerge-constants","text":"String constants creating Automerge objects: AM_OBJ_TYPE_LIST Create list (array) object. Lists ordered sequences accessed numeric index (1-based R). AM_OBJ_TYPE_MAP Create map (object) object. Maps unordered key-value collections accessed string keys. AM_OBJ_TYPE_TEXT Create text object collaborative editing. Text objects support character-level CRDT operations, cursor stability, formatting marks. Use text objects collaborative document editing rather regular strings (use last-write-wins semantics).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-constants.html","id":"mark-expansion-modes","dir":"Reference","previous_headings":"","what":"Mark Expansion Modes","title":"Automerge Constants â€” automerge-constants","text":"Constants controlling text marks expand text inserted boundaries (used am_mark_create): AM_MARK_EXPAND_NONE Mark expand text inserted either boundary. AM_MARK_EXPAND_BEFORE Mark expands include text inserted immediately start position. AM_MARK_EXPAND_AFTER Mark expands include text inserted immediately end position. AM_MARK_EXPAND_BOTH Mark expands include text inserted either boundary (start end).","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-package.html","id":null,"dir":"Reference","previous_headings":"","what":"automerge: R Bindings for Automerge CRDT Library â€” automerge-package","title":"automerge: R Bindings for Automerge CRDT Library â€” automerge-package","text":"Provides R bindings Automerge Conflict-free Replicated Data Type (CRDT) library via C FFI. Automerge enables automatic merging concurrent changes without conflicts, making ideal distributed systems, collaborative applications, offline-first architectures. package supports Automerge data types (maps, lists, text, counters) provides low-level high-level synchronization protocols seamless interoperability JavaScript Automerge implementations.","code":""},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/reference/automerge-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"automerge: R Bindings for Automerge CRDT Library â€” automerge-package","text":"Maintainer: Charlie Gao charlie.gao@posit.co (ORCID) contributors: Posit Software, PBC (ROR) [copyright holder, funder]","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract from Automerge document root â€” extract-am_doc","title":"Extract from Automerge document root â€” extract-am_doc","text":"Extract values root Automerge document using [[ $. operators provide R-idiomatic access document data.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract from Automerge document root â€” extract-am_doc","text":"","code":"# S3 method for class 'am_doc' x[[i]]  # S3 method for class 'am_doc' x$name"},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract from Automerge document root â€” extract-am_doc","text":"x Automerge document Key name (character) name Key name ($ operator)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract from Automerge document root â€” extract-am_doc","text":"value specified key","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_doc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract from Automerge document root â€” extract-am_doc","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"name\", \"Alice\") am_put(doc, AM_ROOT, \"age\", 30L)  doc[[\"name\"]]  # \"Alice\" #> [1] \"Alice\" doc$age        # 30L #> [1] 30"},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract from Automerge object â€” extract-am_object","title":"Extract from Automerge object â€” extract-am_object","text":"Extract values Automerge object (map list) using [[ $.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract from Automerge object â€” extract-am_object","text":"","code":"# S3 method for class 'am_object' x[[i]]  # S3 method for class 'am_object' x$name"},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract from Automerge object â€” extract-am_object","text":"x Automerge object Key name (character) maps, position (integer) lists name Key name ($ operator, maps )","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract from Automerge object â€” extract-am_object","text":"value specified key/position","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/extract-am_object.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract from Automerge object â€” extract-am_object","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"user\", list(name = \"Bob\", age = 25L)) user <- am_get(doc, AM_ROOT, \"user\")  user[[\"name\"]]  # \"Bob\" #> [1] \"Bob\" user$age        # 25L #> [1] 25"},{"path":"http://shikokuchuo.net/automerge-r/reference/from_automerge.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Automerge document to R list â€” from_automerge","title":"Convert Automerge document to R list â€” from_automerge","text":"Converts Automerge document standard R list. equivalent .list.am_doc().","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/from_automerge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Automerge document to R list â€” from_automerge","text":"","code":"from_automerge(doc)"},{"path":"http://shikokuchuo.net/automerge-r/reference/from_automerge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Automerge document to R list â€” from_automerge","text":"doc Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/from_automerge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Automerge document to R list â€” from_automerge","text":"Named list document contents","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/from_automerge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Automerge document to R list â€” from_automerge","text":"","code":"doc <- am_create() doc$name <- \"Alice\" doc$age <- 30L  from_automerge(doc)  # list(name = \"Alice\", age = 30L) #> $age #> [1] 30 #>  #> $name #> [1] \"Alice\" #>"},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get length of document root â€” length.am_doc","title":"Get length of document root â€” length.am_doc","text":"Returns number keys root map Automerge document.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get length of document root â€” length.am_doc","text":"","code":"# S3 method for class 'am_doc' length(x)"},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get length of document root â€” length.am_doc","text":"x Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get length of document root â€” length.am_doc","text":"Integer length","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_doc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get length of document root â€” length.am_doc","text":"","code":"doc <- am_create() doc$a <- 1 doc$b <- 2 length(doc)  # 2 #> [1] 2"},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Get length of Automerge object â€” length.am_object","title":"Get length of Automerge object â€” length.am_object","text":"Returns number elements/keys Automerge object.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get length of Automerge object â€” length.am_object","text":"","code":"# S3 method for class 'am_object' length(x)"},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get length of Automerge object â€” length.am_object","text":"x Automerge object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/length.am_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get length of Automerge object â€” length.am_object","text":"Integer length","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Get names from document root â€” names.am_doc","title":"Get names from document root â€” names.am_doc","text":"Returns keys root map Automerge document.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get names from document root â€” names.am_doc","text":"","code":"# S3 method for class 'am_doc' names(x)"},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get names from document root â€” names.am_doc","text":"x Automerge document","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get names from document root â€” names.am_doc","text":"Character vector key names","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_doc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get names from document root â€” names.am_doc","text":"","code":"doc <- am_create() doc$name <- \"Alice\" doc$age <- 30L names(doc)  # c(\"name\", \"age\") #> [1] \"age\"  \"name\""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Get names from Automerge map object â€” names.am_map","title":"Get names from Automerge map object â€” names.am_map","text":"Returns keys map object.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get names from Automerge map object â€” names.am_map","text":"","code":"# S3 method for class 'am_map' names(x)"},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get names from Automerge map object â€” names.am_map","text":"x Automerge map object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/names.am_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get names from Automerge map object â€” names.am_map","text":"Character vector key names","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_counter.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge counter â€” print.am_counter","title":"Print Automerge counter â€” print.am_counter","text":"Print Automerge counter","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_counter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge counter â€” print.am_counter","text":"","code":"# S3 method for class 'am_counter' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_counter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge counter â€” print.am_counter","text":"x Automerge counter ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_counter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge counter â€” print.am_counter","text":"counter (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_cursor.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge cursor â€” print.am_cursor","title":"Print Automerge cursor â€” print.am_cursor","text":"Print Automerge cursor","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_cursor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge cursor â€” print.am_cursor","text":"","code":"# S3 method for class 'am_cursor' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_cursor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge cursor â€” print.am_cursor","text":"x Automerge cursor ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_cursor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge cursor â€” print.am_cursor","text":"cursor (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge document â€” print.am_doc","title":"Print Automerge document â€” print.am_doc","text":"Print method Automerge documents showing basic info root contents.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge document â€” print.am_doc","text":"","code":"# S3 method for class 'am_doc' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge document â€” print.am_doc","text":"x Automerge document ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge document â€” print.am_doc","text":"document (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge list object â€” print.am_list","title":"Print Automerge list object â€” print.am_list","text":"Print Automerge list object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge list object â€” print.am_list","text":"","code":"# S3 method for class 'am_list' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge list object â€” print.am_list","text":"x Automerge list object ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge list object â€” print.am_list","text":"object (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_map.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge map object â€” print.am_map","title":"Print Automerge map object â€” print.am_map","text":"Print Automerge map object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_map.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge map object â€” print.am_map","text":"","code":"# S3 method for class 'am_map' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_map.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge map object â€” print.am_map","text":"x Automerge map object ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_map.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge map object â€” print.am_map","text":"object (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge object (fallback for unknown types) â€” print.am_object","title":"Print Automerge object (fallback for unknown types) â€” print.am_object","text":"Print Automerge object (fallback unknown types)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge object (fallback for unknown types) â€” print.am_object","text":"","code":"# S3 method for class 'am_object' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge object (fallback for unknown types) â€” print.am_object","text":"x Automerge object ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge object (fallback for unknown types) â€” print.am_object","text":"object (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_syncstate.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge sync state â€” print.am_syncstate","title":"Print Automerge sync state â€” print.am_syncstate","text":"Print Automerge sync state","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_syncstate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge sync state â€” print.am_syncstate","text":"","code":"# S3 method for class 'am_syncstate' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_syncstate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge sync state â€” print.am_syncstate","text":"x Automerge sync state ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_syncstate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge sync state â€” print.am_syncstate","text":"sync state (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_text.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Automerge text object â€” print.am_text","title":"Print Automerge text object â€” print.am_text","text":"Print Automerge text object","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_text.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Automerge text object â€” print.am_text","text":"","code":"# S3 method for class 'am_text' print(x, ...)"},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_text.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Automerge text object â€” print.am_text","text":"x Automerge text object ... Additional arguments (unused)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/print.am_text.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Automerge text object â€” print.am_text","text":"object (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_doc.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace in Automerge document root â€” replace-am_doc","title":"Replace in Automerge document root â€” replace-am_doc","text":"Replace insert values root Automerge document using [[<- $<-. operators provide R-idiomatic modification.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_doc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace in Automerge document root â€” replace-am_doc","text":"","code":"# S3 method for class 'am_doc' x[[i]] <- value  # S3 method for class 'am_doc' x$name <- value"},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_doc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace in Automerge document root â€” replace-am_doc","text":"x Automerge document Key name (character) value Value store name Key name ($<- operator)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_doc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace in Automerge document root â€” replace-am_doc","text":"document (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_doc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace in Automerge document root â€” replace-am_doc","text":"","code":"doc <- am_create() doc[[\"name\"]] <- \"Bob\" doc$age <- 25L"},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_object.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace in Automerge object â€” replace-am_object","title":"Replace in Automerge object â€” replace-am_object","text":"Replace insert values Automerge object using [[<- $<-.","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_object.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace in Automerge object â€” replace-am_object","text":"","code":"# S3 method for class 'am_object' x[[i]] <- value  # S3 method for class 'am_object' x$name <- value"},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_object.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace in Automerge object â€” replace-am_object","text":"x Automerge object Key name (character) maps, position (integer) lists value Value store name Key name ($<- operator, maps )","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_object.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace in Automerge object â€” replace-am_object","text":"object (invisibly)","code":""},{"path":"http://shikokuchuo.net/automerge-r/reference/replace-am_object.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Replace in Automerge object â€” replace-am_object","text":"","code":"doc <- am_create() am_put(doc, AM_ROOT, \"user\", list(name = \"Bob\", age = 25L)) user <- am_get(doc, AM_ROOT, \"user\")  user[[\"name\"]] <- \"Alice\" user$age <- 30L"},{"path":[]},{"path":"http://shikokuchuo.net/automerge-r/news/index.html","id":"automerge-010","dir":"Changelog","previous_headings":"","what":"automerge 0.1.0","title":"automerge 0.1.0","text":"Initial implementation.","code":""}]

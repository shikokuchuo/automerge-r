---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# automerge

<!-- badges: start -->
[![R-CMD-check](https://github.com/shikokuchuo/automerge-r/actions/workflows/R-CMD-check.yaml/badge.svg)](https://github.com/shikokuchuo/automerge-r/actions/workflows/R-CMD-check.yaml)
[![Codecov test coverage](https://codecov.io/gh/shikokuchuo/automerge-r/graph/badge.svg)](https://app.codecov.io/gh/shikokuchuo/automerge-r)
<!-- badges: end -->

R Bindings for the Automerge CRDT Library

## Overview

`automerge` provides R bindings to the [Automerge](https://automerge.org/) Conflict-free Replicated Data Type (CRDT) library via its C FFI. Automerge enables automatic merging of concurrent changes without conflicts, making it ideal for:

- Distributed systems
- Collaborative applications
- Offline-first architectures
- Cross-platform data synchronization

## Features

- Full support for Automerge data types: maps, lists, text, counters
- Intuitive functional API with S3 methods
- Low-level and high-level synchronization protocols
- Seamless interoperability with JavaScript and other Automerge implementations
- Zero runtime dependencies (only base R)

## Installation

### From Source (Development Version)

```r
# Install from GitHub
pak::pak("posit-dev/automerge-r")
```

### System Requirements

To build from source, you need:

- Rust toolchain >= 1.89.0 - Install from https://rustup.rs/
- CMake >= 3.25 - Included in Rtools43+ on Windows

Alternatively, install `automerge-c` (with UTF-32 character indexing enabled) system-wide to skip the source build.

## Status

ðŸš§ **Under Active Development** ðŸš§

This package is currently in the initial development phase. Core functionality is not yet implemented and any existing functionality is subject to change at any time.

## Example Usage

### Creating and Modifying Documents

Use familiar R syntax to work with Automerge documents:

```{r}
library(automerge)

doc <- am_create()
doc$name <- "Alice"
doc$age <- 20L
doc[["active"]] <- TRUE
doc
```

### Reading Values

Access values just like a regular R list:

```{r}
doc$name
doc[["age"]]
```

### Nested Structures

Create complex nested objects in a single call:

```{r}
doc$user <- list(
  name = "Bob",
  age = 25L,
  address = list(city = "NYC", zip = 10001L)
)
```

Nested objects work independently:

```{r}
user <- doc$user
user$email <- "bob@example.com"
user
```

### Advanced Types

Automerge supports specialized CRDT types:

```{r}
doc$created <- Sys.time() # POSIXct timestamp
doc$score <- am_counter(0) # Counter
doc$notes <- am_text("ä¸–ç•Œ") # Text object with CRDT semantics
```

### Working with Text

Text objects support fine-grained editing:

```{r}
text_obj <- doc$notes
text_obj
am_text_splice(text_obj, 2, 0, "ðŸŒ")
am_text_get(text_obj)
```

### Utility Methods

Standard R operations work as expected:

```{r}
length(doc) # Number of keys
names(doc) # Key names
as.list(doc) # Convert to R list
```

### Saving and Loading

Persist documents to disk or transfer over network:

```{r}
doc |> am_commit("Initial data")
bytes <- am_save(doc)
str(bytes)

doc2 <- am_load(bytes)
doc2
```

### Forking and Merging

Create independent copies and merge changes automatically:

```{r}
doc3 <- am_fork(doc)
doc3$name <- "Charlie"

am_merge(doc, doc3)
doc$name
```

### Low-Level API

For fine-grained control, use the functional API:

```{r}
doc <- am_create()
am_put(doc, AM_ROOT, "name", "Alice")
am_put(doc, AM_ROOT, "age", 20L)
doc
```

## Synchronization

Automerge's core strength is automatic synchronization of concurrent changes across multiple documents. The package provides both low-level sync protocol access and high-level convenience functions.

### Basic Synchronization

The simplest way to sync two documents:

```{r}
# Create two documents with different changes
doc1 <- am_create()
doc1$x <- 1
doc1$y <- 2
am_commit(doc1, "Add x and y")

doc2 <- am_create()
doc2$a <- "hello"
doc2$b <- "world"
am_commit(doc2, "Add a and b")

# Synchronize them automatically
result <- am_sync_bidirectional(doc1, doc2)
cat("Synced in", result$rounds, "rounds\n")

# Both documents now have all keys
doc1
doc2
```

### Concurrent Edits

Automerge automatically resolves conflicts from concurrent edits:

```{r}
# Start with a synchronized document
doc1 <- am_create()
doc1$counter <- 0
am_commit(doc1)

# Fork to create independent copy
doc2 <- am_fork(doc1)

# Make different changes in each document
doc1$counter <- 10
doc1$edited_by <- "Alice"
am_commit(doc1, "Alice's changes")

doc2$counter <- 20
doc2$edited_by <- "Bob"
am_commit(doc2, "Bob's changes")

# Sync automatically resolves conflicts
am_sync_bidirectional(doc1, doc2)

# Both documents converge to the same state
# The counter value is deterministically chosen (CRDT semantics)
doc1$counter == doc2$counter
doc1$edited_by == doc2$edited_by
```

### Manual Change Management

For custom sync workflows, use the low-level change tracking API:

```{r}
# Track document history
doc <- am_create()
doc$version <- 1
am_commit(doc, "v1")

doc$version <- 2
am_commit(doc, "v2")

# Get all changes
changes <- am_get_changes(doc, NULL)
cat("Number of changes:", length(changes), "\n")

# Apply changes to another document
doc_replica <- am_create()
am_apply_changes(doc_replica, changes)

doc_replica$version
```

### Low-Level Sync Protocol

For network synchronization or custom protocols:

```{r}
# Create two documents with different data
doc1 <- am_create()
doc1$from_doc1 <- "Alice's data"
doc1$priority <- 1L
am_commit(doc1)

doc2 <- am_create()
doc2$from_doc2 <- "Bob's data"
doc2$priority <- 2L
am_commit(doc2)

# Create sync states (one per peer)
sync1 <- am_sync_state_new()
sync2 <- am_sync_state_new()

# Generate sync message from doc1
msg <- am_sync_encode(doc1, sync1)

# Receive and apply on doc2
am_sync_decode(doc2, sync2, msg)

# Generate response from doc2
response <- am_sync_encode(doc2, sync2)

# Continue until both return NULL (converged)
while (!is.null(response)) {
  am_sync_decode(doc1, sync1, response)
  response <- am_sync_encode(doc1, sync1)
  if (!is.null(response)) {
    am_sync_decode(doc2, sync2, response)
    response <- am_sync_encode(doc2, sync2)
  }
}

# Documents after sync
doc1
doc2
```

### Document Heads

Track document state with change hashes:

```{r}
doc <- am_create()
doc$data <- "initial"
am_commit(doc)

# Get current heads (change hashes)
heads <- am_get_heads(doc)
cat("Number of heads:", length(heads), "\n")

# Make more changes
doc$data <- "updated"
am_commit(doc)

# Heads have changed
new_heads <- am_get_heads(doc)
identical(heads, new_heads)
```

### Use Cases

**Distributed Systems**: Sync R sessions across multiple machines
```{r}
# On machine 1
doc1 <- am_create()
doc1$results <- list(mean = 42, sd = 5)
am_commit(doc1)
temp_file <- tempfile(fileext = ".rds")
saveRDS(am_save(doc1), temp_file)

# On machine 2
doc2 <- am_load(readRDS(temp_file))
doc2$additional_analysis <- list(median = 41, iqr = 8)
am_commit(doc2)
doc2
```

**Collaborative Analysis**: Multiple analysts working on the same dataset
```{r}
# Analyst A adds model results
doc_a <- am_create()
doc_a$model_a <- list(accuracy = 0.95, f1 = 0.93)
am_commit(doc_a, "Model A results")

# Analyst B adds different model (concurrent)
doc_b <- am_create()
doc_b$model_b <- list(accuracy = 0.97, f1 = 0.94)
am_commit(doc_b, "Model B results")

# Sync merges both contributions automatically
am_sync_bidirectional(doc_a, doc_b)

# Both documents now have all models
names(doc_a)
names(doc_b)
```

**Offline-First Workflows**: Make changes offline, sync when connected
```{r}
# Work offline
offline_doc <- am_create()
offline_doc$field_data <- list(
  temp = 23.5,
  humidity = 65,
  timestamp = Sys.time()
)
am_commit(offline_doc, "Offline data collection")

# Central repository has other data
central_doc <- am_create()
central_doc$processed_data <- list(status = "ready", samples = 100L)
am_commit(central_doc, "Central data")

# Later, sync with central repository
am_sync_bidirectional(offline_doc, central_doc)

# Both documents have all data
names(offline_doc)
names(central_doc)
```

## Resources

- [Automerge Website](https://automerge.org/)
- [Automerge GitHub](https://github.com/automerge/automerge)
